[{"title":"Hello World","date":"2019-11-04T07:30:18.600Z","path":"2019/11/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Vuejs在資料綁定時會複製更新並替換目標元素","date":"2019-11-04T02:44:10.455Z","path":"2019/11/04/more/2017-04-06-vuejs-how-vuejs-makes-a-copy-update-replace-inside-the-data-binding/","text":"概述Vuejs是一款簡單而強大的軟體傑作，類似其它流行的UI框架，Angularjs和Reactjs，但不像這兩者令人生畏的複雜性，Vue非常簡單，在從入門到放棄之前，你能很快掌握它的全部知識並投入生產。 但是如果你不知道它怎麼工作的，有時候它也會難為你。這裡是一個和其它UI框架(Framework7)衝突的例子。 12345678910111213141516&lt;!-- index.html --&gt;&lt;div class=\"pages\"&gt; &lt;div class=\"page\" date-page=\"index\"&gt; &lt;!-- load a new page --&gt; &lt;a href=\"test.html\"&gt;new page&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- test.html --&gt;&lt;div class=\"pages\"&gt; &lt;div class=\"page\" date-page=\"test\" id=\"test\"&gt; &lt;div class=\"page-content\" id=\"test1\"&gt; &lt;p&gt;&#123;% raw %&#125;&#123;&#123;content&#125;&#125;&#123;% endraw %&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789var myApp = new Framework7();myApp.onPageInit('test', function (page) &#123; new Vue(&#123; el: '#test', data: &#123; content: 'hello world' &#125; &#125;);&#125;); 你可能會驚訝它竟然無法工作，新的page點擊後並沒有顯示出來。事實上，Vue內部會複製目標HTML元素，然後根據綁定的資料更新並替換原來的元素。當Framework7載入新的頁面時，它會調用PageInit回呼函數，這裡我們又調用了Vue在&lt;page&gt;元素上資料綁定，這之後DOM樹裡面包含的已經是新的&lt;page&gt;元素，但Framework7對此並不知情又接著在舊的&lt;page&gt;元素上完成剩下的初始化工作，比如最終顯示這個新的頁面，這就是根本原因。 為了繞過這個問題，不要讓Vue的元素選擇器錨定在&lt;page&gt;元素上，而是定在它的子元素，這樣Vue做資料綁定時就不會影響到整個頁面顯示。 123456789var myApp = new Framework7();myApp.onPageInit('test', function (page) &#123; new Vue(&#123; el: '#test1', data: &#123; content: 'hello world' &#125; &#125;);&#125;); 更多資訊 Vue [Vue教程] (https://cn.vuejs.org/) Framework7","tags":[]},{"title":"Array 的三个技巧","date":"2019-11-04T02:44:10.455Z","path":"2019/11/04/javascript/2017-03-12-3-array-hacks/","text":"在 JavaScript 中 数组（Array）随处可见，使用ECMAScript 6 中的新特性 扩展运算符 你可以做很多很棒事情。在这边文章中，我将为你介绍在编码中有用的3个技巧。 1. 迭代一个空数组JavaScript 中直接创建的数组是松散的，以至于会有很多坑。试着用数组的构造方法创建一个数组，你就会明白我的意思。 12&gt; const arr = new Array(4);[undefined, undefined, undefined, undefined] 你会发现，通过一个松散的数组去循环调用一些转换是非常难的。 123&gt; const arr = new Array(4);&gt; arr.map((elem, index) =&gt; index);[undefined, undefined, undefined, undefined] 想要解决这个问题，你可以使用在创建新数组的时候使用 Array.apply。 123&gt; const arr = Array.apply(null, new Array(4));&gt; arr.map((elem, index) =&gt; index);[0, 1, 2, 3] 2. 给方法传一个空参数如果你想调用一个方法，并不填其中的一个参数时，JavaScript 就会报错。 12&gt; method('parameter1', , 'parameter3');Uncaught SyntaxError: Unexpected token , 一个人们常用的解决方法是传递 null 或 undefined. 12&gt; method('parameter1', null, 'parameter3') // or&gt; method('parameter1', undefined, 'parameter3'); 自从 JavaScript 把 null 当做一个 object 的时候， 我个人就不太喜欢使用它了。根据 ES6 中对扩展运算符的介绍，有一个更简洁的方法可以将空参数传递给一个方法。正如前文所提到的，数组是松散的，所以给它传空值是可以的，我们正式用到了这个优点。 1&gt; method(...['parameter1', , 'parameter3']); // works! 数组去重我一直不明白为什么数组不提供一个内置函数可以让我们方便的取到去重以后的值。扩展运算符帮到了我们，使用扩展运算符配合 Set Spread operators are here for the rescue. Use spread operators with the Set 可以生成一个不重复的数组。 12&gt; const arr = [...new Set([1, 2, 3, 3])];[1, 2, 3]","tags":[]},{"title":"使用 tap 来快速 debug","date":"2019-11-04T02:44:10.455Z","path":"2019/11/04/javascript/2017-03-16-tapping-for-quick-debugging/","text":"在这里 tap 是一个小怪物。一个可以用来快速调试、链式调用、匿名函数，还可以打印任何你想打印的东西的函数。 1234function tap(x) &#123; console.log(x); return x;&#125; 为什么我们不用 console.log 这个老方式了？让我来示范一个例子： 12345bank_totals_by_client(bank_info(1, banks), table) .filter(c =&gt; c.balance &gt; 25000) .sort((c1, c2) =&gt; c1.balance &lt;= c2.balance ? 1 : -1 ) .map(c =&gt; console.log(`$&#123;c.id&#125; | $&#123;c.tax_number&#125; ($&#123;c.name&#125;) =&gt; $&#123;c.balance&#125;`)); 现在，加入你从这个链式调用中没有得到任何返回。在哪里除了问题呢？或许 bank_info 没有返回东西，我们需要监听（tap）它: 1bank_totals_by_client(tap(bank_info(1, banks)), table) 基于我们特殊的实现，它可能会打印一些东西，也可能什么也不打印。我们假设，打印出来的东西是正确的，因此， bank_info 没有问题。 我们需要继续调试下一个函数， filter. 1.filter(c =&gt; tap(c).balance &gt; 25000) 我们可以得到 c 吗？如果可以，说明 bank_totals_by_client 运行正常。可能是 filter 内的条件有问题？ 1.filter(c =&gt; tap(c.balance &gt; 25000)) 啊哈！我们发现除了 false 没有打印其他东西，所以说明没有一个 client &gt;25000，这就是为什么方法什么也没返回的原因。 (附) 更先进的 tap1234function tap(x, fn = x =&gt; x) &#123; console.log(fn(x)); return x;&#125; 让我们来看一下一个更强大的怪物，如果我们想在监听（tap）之前事先做一些操作应该怎么办？比如，我们只想方位某个对象特定的参数，位于一个逻辑运算，等等。使用上面的方法，在调用的时候增加一个额外参数，这个函数在被监听（tap）的时候就会被执行。 1tap(3, x =&gt; x + 2) === 3; // prints 5, but expression evaluates to true, why :-)?","tags":[]},{"title":"为什么你应该在相等比较中使用 Object.is()","date":"2019-11-04T02:44:10.455Z","path":"2019/11/04/javascript/2017-04-03-why-you-should-use-Object.is()-in-equality-comparison/","text":"我们都知道 JavasSript 是弱类型的，并且当我们使用 == 作比较时，在一些情况下由于类型转换或者说“把两个操作数中的一个转换成另一个，然后在比较”，会出现意想不到的结果。 1230 == ' ' //truenull == undefined //true[1] == true //true 因此 JavaScript 中给我们提供了全等操作符 ===, 它比不全等操作符更加严格并且不会发生类型转换。但是用 === 来进行比较并不是最好的解决方案。你可能会得到： 1NaN === NaN //false 好消息是 ES6 中提供了新的 Object.is() 方法，它具有 === 的一些特点，而且更好、更精确，在一些特殊案例中表现的很好： 1234Object.is(0 , ' '); //falseObject.is(null, undefined); //falseObject.is([1], true); //falseObject.is(NaN, NaN); //true Mozilla 团队并不认为 Object.is 比 === 更加“严格”，他们说我们应该考虑的是这个方法如何处理 NaN, -0 和 +0。但是总的来说， 我认为它在实际应用中是一个很好的实践。 现在来看看这张图表的对比… References:Equality comparisons and sameness","tags":[]},{"title":"选择（picking）和反选（rejecting）对象的属性","date":"2019-11-04T02:44:10.455Z","path":"2019/11/04/javascript/2017-04-05-picking-and-rejecting-object-properties/","text":"有时候我们需要将一个对象的某些属性放到白名单里，这样来说，我们有一个数组代表了一张数据库表，并且为了一些功能我们需要从中选出（select）一些字段： 12345678910111213141516171819function pick(obj, keys) &#123; return keys.map(k =&gt; k in obj ? &#123;[k]: obj[k]&#125; : &#123;&#125;) .reduce((res, o) =&gt; Object.assign(res, o), &#123;&#125;);&#125;const row = &#123; 'accounts.id': 1, 'client.name': 'John Doe', 'bank.code': 'MDAKW213'&#125;;const table = [ row, &#123;'accounts.id': 3, 'client.name': 'Steve Doe', 'bank.code': 'STV12JB'&#125;];pick(row, ['client.name']); // 取到了 client nametable.map(row =&gt; pick(row, ['client.name'])); // 取到了一系列 client name 在 pick 函数中用到了一点‘诡计’。首先，我们用 map 遍历了键名数组（keys）, 每次都会返回一个包含当前键名（key）的对象（如果在目标对象（obj）中没有当前键名，就会返回空对象）。然后我们用 reduce 把返回的所有单个键-值对象和合并到一个对象中。 但是，如果我们想反选（reject）属性／键名呢？改造一下我们的函数就好了： 123456789101112131415function reject(obj, keys) &#123; return Object.keys(obj) .filter(k =&gt; !keys.includes(k)) .map(k =&gt; (&#123;[k]: obj[k]&#125;)) .reduce((res, o) =&gt; Object.assign(res, o), &#123;&#125;);&#125;// 或者, 利用 pickfunction reject(obj, keys) &#123; const vkeys = Object.keys(obj) .filter(k =&gt; !keys.includes(k)); return pick(obj, vkeys);&#125;reject(&#123;a: 2, b: 3, c: 4&#125;, ['a', 'b']); // =&gt; &#123;c: 4&#125;","tags":[]},{"title":"子容器的Key是很重要的","date":"2019-11-04T02:44:10.455Z","path":"2019/11/04/react/2016-01-02-keys-in-children-components-are-important/","text":"key必须传递给从数组中动态创建的所有组件的一个值。它是一个唯一且固定的id，用来识别DOM中的每个组件，也可以让我们区别它是否是同一个组件。使用key可以确保子容器是可保存而且不需要重复创建的，还可以防止奇怪的事情发生。 key跟效率不是很相关，它更与身份有关系（这间接的使效率更好）。随机的赋值或改变值将不能识别身份Paul O’Shannessy 使用对象存在的的唯一值。 在父组件定义key,而不是子组件。 123456789//bad...render() &#123; &lt;div key=&#123;% raw %&#125;&#123;&#123;item.key&#125;&#125;&#123;% endraw %&#125;&gt;&#123;% raw %&#125;&#123;&#123;item.name&#125;&#125;&#123;% endraw %&#125;&lt;/div&gt;&#125;...//good&lt;MyComponent key=&#123;% raw %&#125;&#123;&#123;item.key&#125;&#125;&#123;% endraw %&#125;/&gt; 使用数组索引是一个坏习惯 random() 不会起作用 12//bad&lt;MyComponent key=&#123;% raw %&#125;&#123;&#123;Math.random()&#125;&#125;&#123;% endraw %&#125;/&gt; 你可以创建以自己的唯一id。确定这个方法运行速度够快，把它附着到你的对象上。 当子组件的数量很大或者包含重量级的组件时，使用key来提高性能。 你必须提供key值给ReactCSSTransitionGroup的每个子组件","tags":[]},{"title":"JavaScript 的逗号操作符","date":"2019-11-04T02:44:10.454Z","path":"2019/11/04/javascript/2016-08-10-comma-operaton-in-js/","text":"除了分号之外，逗号允许你在同一个地方放多个语句。例如： 123for(var i=0, j=0; i&lt;5; i++, j++, j++)&#123; console.log(\"i:\"+i+\", j:\"+j);&#125; 輸出： 12345i:0, j:0i:1, j:2i:2, j:4i:3, j:6i:4, j:8 当放一个表达式时，它由左到右计算每个表达式，并传回最右边的表达式。 例如： 1234567function a()&#123;console.log('a'); return 'a';&#125;function b()&#123;console.log('b'); return 'b';&#125;function c()&#123;console.log('c'); return 'c';&#125;var x = (a(), b(), c());console.log(x); // 输出「c」 输出： 12345\"a\"\"b\"\"c\"\"c\" 注意：逗号（,）操作符在 JavaScript 中所有的操作符里是最低的优先顺序，所以没有括号表达式将变为：(x = a()), b(), c();。 实验 JS Bin on jsbin.com","tags":[]},{"title":"复制到粘贴板","date":"2019-11-04T02:44:10.454Z","path":"2019/11/04/javascript/2016-08-02-copy-to-clipboard/","text":"这是一个简单的小知识，本周我做了一个简单的“复制到剪贴板”按钮，这是我第一次做这种功能，向大家分享一下我的实现方法。 这很简单，比较麻烦的是我们必须为需要复制的文本增加&lt;input/&gt;标签。之后我们选择要复制的内容然后调用复制命令execCommand.execCommand(&#39;copy&#39;) 将会复制被选择的内容。 此方法目前被所有最新版本的浏览器支持，它可以让我们执行如复制、剪切、粘贴等命令，还可以改变字体颜色、大小等。 12document.querySelector('#input').select();document.execCommand('copy'); 具体表现看这里","tags":[]},{"title":"给函数 Bind 对象","date":"2019-11-04T02:44:10.454Z","path":"2019/11/04/javascript/2017-01-19-binding-objects-to-functions/","text":"我们常常需要将一个对象绑定到一个方法的 this 上。在 JS 中，如果你想要调用一个函数并指定它的 this 时可以使用 bind 方法。 Bind 语法1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。 arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值 返回由指定的this值和初始化参数改造的原函数拷贝 JS 中的实例1234567891011121314151617181920212223242526const myCar = &#123; brand: 'Ford', type: 'Sedan', color: 'Red'&#125;;const getBrand = function () &#123; console.log(this.brand);&#125;;const getType = function () &#123; console.log(this.type);&#125;;const getColor = function () &#123; console.log(this.color);&#125;;getBrand(); // object not bind,undefinedgetBrand(myCar); // object not bind,undefinedgetType.bind(myCar)(); // Sedanlet boundGetColor = getColor.bind(myCar);boundGetColor(); // Red","tags":[]},{"title":"处理 Websocket 超时问题","date":"2019-11-04T02:44:10.454Z","path":"2019/11/04/javascript/2017-03-09-working-with-websocket-timeout/","text":"在 websocket 连接被建立后，如果一段时间未活动，服务器或防火墙可能会超时或终止连接。想要解决这个问题， 我们可以周期性地给服务器发消息。我们需要两个方法实现：一个来确保连接不会中断，，另一个用来取消此设定。同我们也需要一个 timerID 变量. 让我们来看一下具体实现： 12345678910111213var timerID = 0; function keepAlive() &#123; var timeout = 20000; if (webSocket.readyState == webSocket.OPEN) &#123; webSocket.send(''); &#125; timerId = setTimeout(keepAlive, timeout); &#125; function cancelKeepAlive() &#123; if (timerId) &#123; clearTimeout(timerId); &#125; &#125; 现在我们实现了我们需要的两个方法，我们可以在 onOpen() 的最后面调用 keepAlive() ，在onClose() 的组后面调用 cancelKeepAlive()。 好了！我们我们完美的解决了 websocket 超时的问题。","tags":[]},{"title":"三个实用的javascript小技巧","date":"2019-11-04T02:44:10.454Z","path":"2019/11/04/javascript/2016-10-28-three-useful-hacks/","text":"从后向前获取数组元素如果你想从后向前获取一个数组的元素，可以这样写： 123456var newArray = [1, 2, 3, 4]console.log(newArray.slice(-1)) // [4]console.log(newArray.slice(-2)) // [3, 4]console.log(newArray.slice(-3)) // [2, 3, 4]console.log(newArray.slice(-4)) // [1, 2, 3, 4] 短路条件句如果你想在某个条件逻辑值为true时，执行某个函数，就像这样： 123if (condition) &#123; dosomething()&#125; 这时，你可以这样子运用短路： 1condition &amp;&amp; dosomething() 用操作符 “||” 来设置默认值如果你必须给一个变量赋默认值，可以简单的这样写： 1234567891011var aconsole.log(a) // undefineda = a || 'default value'console.log(a) // default valuea = a || 'new value'console.log(a) // default value","tags":[]},{"title":"break 或 continue 循环函数","date":"2019-11-04T02:44:10.454Z","path":"2019/11/04/javascript/2016-08-17-break-continue-loop-functional/","text":"停止循环是循环中一个常见的需求。使用for循环我们可以用break提前结束循环。 12345678const a = [0, 1, 2, 3, 4];for (var i = 0; i &lt; a.length; i++) &#123; if (a[i] === 2) &#123; break; // stop the loop &#125; console.log(a[i]);&#125;//&gt; 0, 1 另一个常见的需求使我们需要直接取得变量。 一个快速的方式是使用.forEach，但是这样我们就失去了break的能力。这种情况下，最接近的方式是使用return实现continue的功能。 12345678[0, 1, 2, 3, 4].forEach(function(val, i) &#123; if (val === 2) &#123; // 怎么停止呢? return true; &#125; console.log(val); // your code&#125;);//&gt; 0, 1, 3, 4 .some是一个原型方法。他用来检测是否某些元素满足所提供的函数。如果任何元素最终返回true，它就会停止运行。更多解释请看MDN。 引子上面链接的一个例子： 1234const isBiggerThan10 = numb =&gt; numb &gt; 10;[2, 5, 8, 1, 4].some(isBiggerThan10); // false[12, 5, 8, 1, 4].some(isBiggerThan10); // true 使用.some我们拥有了类似.forEach的功能，而且使用return实现了break的效果。 1234567[0, 1, 2, 3, 4].some(function(val, i) &#123; if (val === 2) &#123; return true; &#125; console.log(val); // your code&#125;);//&gt; 0, 1 你可以返回false使循环continue到下一个元素。当你返回true时，循环将会break，此时a.some(..)将会return true。 12345678// Array contains 2const isTwoPresent = [0, 1, 2, 3, 4].some(function(val, i) &#123; if (val === 2) &#123; return true; // break &#125;&#125;);console.log(isTwoPresent);//&gt; true 还有.every函数同样可以实现此功能。但此时我们需要返回与.some相反的布尔值。 示例 JS Bin on jsbin.com","tags":[]},{"title":"var和ES6的let","date":"2019-11-04T02:44:10.454Z","path":"2019/11/04/javascript/2016-08-25-keyword-var-vs-let/","text":"概述 通过 var 定义的变量，它的作用域是在 function 或任何外部已经被声明的 function，是全域的 。 透過 let 定义的变量，它的作用域是在一個块（block）。 123456789101112131415161718function varvslet() &#123; console.log(i); // i 是 undefined 的，因为变量提升 // console.log(j); // ReferenceError: j 没有被定义 for( var i = 0; i &lt; 3; i++ ) &#123; console.log(i); // 0, 1, 2 &#125;; console.log(i); // 3 // console.log(j); // ReferenceError: j 没有被定义 for( let j = 0; j &lt; 3; j++ ) &#123; console.log(j); &#125;; console.log(i); // 3 // console.log(j); // ReferenceError: j 没有被定义&#125; 详细的区别 变量提升 let 不會被提升到整个块的作用域。相比之下，var 可以被提升。 123456789&#123; console.log(c); // undefined。因为变量提升 var c = 2;&#125;&#123; console.log(b); // ReferenceError: b 没有被定义 let b = 3;&#125; 循环中的闭包 let 在每次循环可以重新被 bind，确保在它之前结束的循环被重新赋值，所以在闭包中它被用來避免一些问题。 12345for (var i = 0; i &lt; 5; ++i) &#123; setTimeout(function () &#123; console.log(i); // 输出 '5' 五次 &#125;, 100); &#125; 使用 let 替换 var 123456// print 1, 2, 3, 4, 5for (let i = 0; i &lt; 5; ++i) &#123; setTimeout(function () &#123; console.log(i); // 输出 0, 1, 2, 3, 4 &#125;, 100); &#125; 我们应该用 let 替代 var 嗎？ 不是的，let 是新的块作用域。语法强调在 var 已经是区块作用域时時，let 应该替换 var ，否则请不要替换 var。let 改善了在 JS 作用域的选项，而不是取代。var 对于变量依旧是有用的，可被用在整個 function 之中。 let 兼容性 在 server 端，比如 Node.js，你现在可以安心的使用 let。 在 client 端，通过 transpiler（比如 Traceur），可以安心的使用 let 语法。否则请在这里确认你的浏览器是否支持。 Playground JS Bin on jsbin.com 更多信息 Let keyword vs var keyword For and against let Explanation of let and block scoping with for loops.","tags":[]},{"title":"用数组建立一个简单的循环","date":"2019-11-04T02:44:10.454Z","path":"2019/11/04/javascript/2016-05-12-make-easy-loop-on-array/","text":"有时我们需要不停的循环数组的元素，就像一组旋转的图片，或者音乐的播放列表。这里告诉你如何使一个数组拥有循环的能力： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var aList = ['A','B','C','D','E'];function make_looper( arr )&#123; arr.loop_idx = 0; // 返回当前的元素 arr.current = function()&#123; if( this.loop_idx &lt; 0 )&#123;// 第一次检查 this.loop_idx = this.length - 1;// 更新 loop_idx &#125; if( this.loop_idx &gt;= this.length )&#123;// 第二次检查 this.loop_idx = 0;// 更新 loop_idx &#125; return arr[ this.loop_idx ];//返回元素 &#125;; // 增加 loop_idx 然后返回新的当前元素 arr.next = function()&#123; this.loop_idx++; return this.current(); &#125;; // 减少 loop_idx 然后返回新的当前元素 arr.prev = function()&#123; this.loop_idx--; return this.current(); &#125;;&#125;make_looper( aList);aList.current();// -&gt; AaList.next();// -&gt; BaList.next();// -&gt; CaList.next();// -&gt; DaList.next();// -&gt; EaList.next();// -&gt; AaList.pop() ;// -&gt; EaList.prev();// -&gt; DaList.prev();// -&gt; CaList.prev();// -&gt; BaList.prev();// -&gt; AaList.prev();// -&gt; D 使用 % ( 取模 ) 操作符更优雅。取模返回除法的余数 ( 2 % 5 = 1 and 5 % 5 = 0)： 1234567891011121314151617181920212223242526272829303132333435363738394041var aList = ['A','B','C','D','E'];function make_looper( arr )&#123; arr.loop_idx = 0; // return current item arr.current = function()&#123; this.loop_idx = ( this.loop_idx ) % this.length;// 无需检查 !! return arr[ this.loop_idx ]; &#125;; // 增加 loop_idx 然后返回新的当前元素 arr.next = function()&#123; this.loop_idx++; return this.current(); &#125;; // 减少 loop_idx 然后返回新的当前元素 arr.prev = function()&#123; this.loop_idx += this.length - 1; return this.current(); &#125;;&#125;make_looper( aList);aList.current();// -&gt; AaList.next();// -&gt; BaList.next();// -&gt; CaList.next();// -&gt; DaList.next();// -&gt; EaList.next();// -&gt; AaList.pop() ;// -&gt; EaList.prev();// -&gt; DaList.prev();// -&gt; CaList.prev();// -&gt; BaList.prev();// -&gt; AaList.prev();// -&gt; D","tags":[]},{"title":"简单获取unix时间戳","date":"2019-11-04T02:44:10.453Z","path":"2019/11/04/javascript/2016-02-26-extract-unix-timestamp-easily/","text":"我们经常需要使用unix时间戳计算。有很多方法可以取得unix时间戳。目前取得unix时间戳最简单最快的方法是： 12const dateTime = Date.now();const timestamp = Math.floor(dateTime / 1000); 或 12const dateTime = new Date().getTime();const timestamp = Math.floor(dateTime / 1000); 要取得一个具体时间的unix时间戳，将yyyy-mm-dd或YYYY-MM-DDT00:00:00Z作为参数传递给Date构造函数。例如 12const dateTime = new Date('2012-06-08').getTime();const timestamp = Math.floor(dateTime / 1000); 你还可以像下面一样，在声明Date对象的时候添加一个+号 12const dateTime = +new Date();const timestamp = Math.floor(dateTime / 1000); 或者对于具体时间 12const dateTime = +new Date('2012-06-08');const timestamp = Math.floor(dateTime / 1000); 在底层，运行时调用了Date对象的valueOf方法。然后一元操作符+调用了之前返回值的toNumber()方法。想要了解更多内容请参考下面链接 Date.prototype.valueOf Unary + operator toNumber() Date Javascript MDN Date.parse()","tags":[]},{"title":"怎样`reduce()`数组","date":"2019-11-04T02:44:10.453Z","path":"2019/11/04/javascript/2016-02-17-reminders-about-reduce-function-usage/","text":"文档里说reduce()方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。 reduce()reduce() 函数接收2个参数(M: 必填, O: 可选)： (M) 回调reducer 函数 处理先前的结算结果和下一个元素直到序列结束。 (O) 初值 作为第一次调用回调时的第一个参数。 所以，让我们先看一个普通用法，之后再看一个复杂用法。 普通用法 (累加，关联)我们正在逛亚马逊(单价为美元$) 我们的购物车实在太满了，我们来计算一下总价吧： 12345678910// 当前的购物清单var items = [&#123;price: 10&#125;, &#123;price: 120&#125;, &#123;price: 1000&#125;];// reducer函数var reducer = function add(sumSoFar, nextPrice) &#123; return sumSoFar + nextPrice.price; &#125;;// 开始运行var total = items.reduce(reducer, 0);console.log(total); // 1130 reduce函数可选的参数在第一个例子里是基本变量数字0，但是它也可以是一个对象，数组… 而不仅是基本类型，之后我们将会看到。 现在，我们收到一个20$的优惠券。 123var total = items.reduce(reducer,-20);console.log(total); // 1110 进阶用法(结合)第二种用法的例子是Redux的combineReducers函数源码里用到的。 此创意是将reducer函数拆分为独立的函数，最后组合成一个新的单一的大reducer函数。 为了说明，我们创建一个单一的对象，包含一些可以计算不同货币($, €…)的总价值的reducer函数。 12345678910111213141516171819var reducers = &#123; totalInDollar: function(state, item) &#123; state.dollars += item.price; return state; &#125;, totalInEuros : function(state, item) &#123; state.euros += item.price * 0.897424392; return state; &#125;, totalInPounds : function(state, item) &#123; state.pounds += item.price * 0.692688671; return state; &#125;, totalInYen : function(state, item) &#123; state.yens += item.price * 113.852; return state; &#125; // more...&#125;; 然后我们建立一个瑞士军刀函数 能够调用每一部分的reduce函数 返回一个新的reducer回调函数 1234567891011var combineTotalPriceReducers = function(reducers) &#123; return function(state, item) &#123; return Object.keys(reducers).reduce( function(nextState, key) &#123; reducers[key](state, item); return state; &#125;, &#123;&#125; ); &#125;&#125;; 现在，我们来看一下如何使用它。 1234567891011var bigTotalPriceReducer = combineTotalPriceReducers(reducers);var initialState = &#123;dollars: 0, euros:0, yens: 0, pounds: 0&#125;;var totals = items.reduce(bigTotalPriceReducer, initialState);console.log(totals);/*Object &#123;dollars: 1130, euros: 1015.11531904, yens: 127524.24, pounds: 785.81131152&#125;*/ 我希望这种方法可以使你在自己的需求内使用reduce()函数时有新的想法。 使用reduce函数也可以实现保存每一次计算结果的功能。这在Ramdajs里的scan函数已经实现了。 在JSFiddle里运行","tags":[]},{"title":"函数中如何使用可选参数（包括可选回调函数）","date":"2019-11-04T02:44:10.453Z","path":"2019/11/04/javascript/2016-05-06-use-optional-arguments/","text":"实例函数中第2个与第3个参数为可选参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function example( err, optionalA, optionalB, callback ) &#123; // 使用数组取出arguments var args = new Array(arguments.length); for(var i = 0; i &lt; args.length; ++i) &#123; args[i] = arguments[i]; &#125;; // 第一个参数为错误参数 // shift() 移除数组中第一个参数并将其返回 err = args.shift(); // 如果最后一个参数是函数，则它为回调函数 // pop() 移除数组中最后一个参数并将其返回 if (typeof args[args.length-1] === 'function') &#123; callback = args.pop(); &#125; // 如果args中仍有元素，那就是你需要的可选参数 // 你可以像这样一个一个的将其取出： if (args.length &gt; 0) optionalA = args.shift(); else optionalA = null; if (args.length &gt; 0) optionalB = args.shift(); else optionalB = null; // 像正常一样继续：检查是否有错误 if (err) &#123; return callback &amp;&amp; callback(err); &#125; // 为了教程目的，打印可选参数 console.log('optionalA:', optionalA); console.log('optionalB:', optionalB); console.log('callback:', callback); /* 你想做的逻辑 */&#125;// ES6语法书写更简短function example(...args) &#123; // 第一个参数为错误参数 const err = args.shift(); // 如果最后一个参数是函数，则它为回调函数 const callback = (typeof args[args.length-1] === 'function') ? args.pop() : null; // 如果args中仍有元素，那就是你需要的可选参数你可以像这样一个一个的将其取出： const optionalA = (args.length &gt; 0) ? args.shift() : null; const optionalB = (args.length &gt; 0) ? args.shift() : null; // ... 重复取更多参数 if (err &amp;&amp; callback) return callback(err); /* 你想做的逻辑 */&#125;// 使用或不适用可选参数调用实例函数example(null, 'AA');example(null, function (err) &#123; /* do something */ &#125;);example(null, 'AA', function (err) &#123;&#125;);example(null, 'AAAA', 'BBBB', function (err) &#123;&#125;); 如何保证optionalA和optionalB是预期的值?设计你的函数，使其在接收optionalB时optionalA为必选参数。","tags":[]},{"title":"取得文件扩展名","date":"2019-11-04T02:44:10.453Z","path":"2019/11/04/javascript/2016-04-21-get-file-extension/","text":"问题 1: 怎样取得文件扩展名?12345678var file1 = \"50.xsl\";var file2 = \"30.doc\";getFileExtension(file1); //returs xslgetFileExtension(file2); //returs docfunction getFileExtension(filename) &#123; /*TODO*/&#125; 解决方法 1: 正则表达式123function getFileExtension1(filename) &#123; return (/[.]/.exec(filename)) ? /[^.]+$/.exec(filename)[0] : undefined;&#125; 解决方法 2: String的split方法123function getFileExtension2(filename) &#123; return filename.split('.').pop();&#125; 这两种解决方法不能解决一些边缘情况，这有另一个更加强大的解决方法。 解决方法 3: String的slice、lastIndexOf方法123456789function getFileExtension3(filename) &#123; return filename.slice((filename.lastIndexOf(\".\") - 1 &gt;&gt;&gt; 0) + 2);&#125;console.log(getFileExtension3('')); // ''console.log(getFileExtension3('filename')); // ''console.log(getFileExtension3('filename.txt')); // 'txt'console.log(getFileExtension3('.hiddenfile')); // ''console.log(getFileExtension3('filename.with.many.dots.ext')); // 'ext' 这是如何实现的呢? String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。 对于&#39;filename&#39;和&#39;.hiddenfile&#39;，lastIndexOf的返回值分别为0和-1无符号右移操作符(&gt;&gt;&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。 String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。 对比 解决方法 参数 结果 解决方法 1: Regular Expression ‘’ ‘filename’ ‘filename.txt’ ‘.hiddenfile’ ‘filename.with.many.dots.ext’ undefined undefined ‘txt’ ‘hiddenfile’ ‘ext’ 解决方法 2: String split ‘’ ‘filename’ ‘filename.txt’ ‘.hiddenfile’ ‘filename.with.many.dots.ext’ ‘’ ‘filename’ ‘txt’ ‘hiddenfile’ ‘ext’ 解决方法 3: String slice, lastIndexOf ‘’ ‘filename’ ‘filename.txt’ ‘.hiddenfile’ ‘filename.with.many.dots.ext’ ‘’ ‘’ ‘txt’ ‘’ ‘ext’ 实例与性能这里 是上面解决方法的实例。 这里 是上面三种解决方法的性能测试。 来源How can I get file extensions with JavaScript","tags":[]},{"title":"new的返回值","date":"2019-11-04T02:44:10.453Z","path":"2019/11/04/javascript/2016-04-05-return-values-with-the-new-operator/","text":"你将会遇到在JavaScript中使用new来分配新对象的一些情况。这将会扰乱你的思绪，除非你阅读了这篇文章并理解在内部发生了什么。 JavaScript中的new操作在合理的情况下然会一个新的对象实例。我们来看，我们有一个构造函数： 123456789function Thing() &#123; this.one = 1; this.two = 2;&#125;var myThing = new Thing();myThing.one // 1myThing.two // 2 提示: this指向new产生的新对象。否则如果Thing()不是用new调用, 将不会生成新对象, 而且this 将会指向全局对象，也就是window。这意味着： 你突然有两个全局变量one和two。 myThing现在为undefined，因为Thing()中没有返回任何东西。 现在我们又有一个例子，而它却有些让人搞不懂。我们看我在构造函数里加了一条语句： 12345678function Thing() &#123; this.one = 1; this.two = 2; return 5;&#125;var myThing = new Thing(); 现在myThing等于什么呢？5？一个对象？还是我受伤的自我价值观？或许永远不知道！ 除了能知道： 12myThing.one // 1myThing.two // 2 很有趣，我们构造函数里返回的5怎么找不到了？这很奇怪不是吗？函数都做了什么？5呢？让我们再试试别的。 我们返回一个非原始类型试一下，比如一个对象： 1234567891011function Thing() &#123; this.one = 1; this.two = 2; return &#123; three: 3, four: 4 &#125;;&#125;var myThing = new Thing(); 让我们试一试。直接console.log出所有内容： 123456console.log(myThing);/* Object &#123;three: 3, four: 4&#125; this.one 和 this.two发生了什么!? 他们被覆盖了，朋友。*/ 我们了解到： 当你使用new关键字调用一个函数的时候，你可以使用this关键字给其设置参数（但这些你应该已经知道了）。使用new关键字调用一个返回原始变量的函数将不会返回你指定的值，而是返回函数的实例this（你指定参数的那个对象，像 this.one = 1;). 然而，返回一个非原始变量像object、array或function将会覆盖this实例，并返回那个非原始变量，有效的破坏了你分配给this的所有工作。","tags":[]},{"title":"简单监听DOM事件","date":"2019-11-04T02:44:10.453Z","path":"2019/11/04/javascript/2016-03-16-DOM-event-listening-made-easy/","text":"很多人还在这样做： element.addEventListener(&#39;type&#39;, obj.method.bind(obj)) element.addEventListener(&#39;type&#39;, function (event) {}) element.addEventListener(&#39;type&#39;, (event) =&gt; {}) 上面所有的例子都创建了一个匿名事件监控句柄，且在不需要时无法删除它。这在你不需要某句柄，而它却被用户或事件冒泡偶然触发时，可能会导致性能问题或不必要的逻辑问题。 更安全的事件处理方式如下： 使用引用： 123456const handler = function () &#123; console.log(\"Tada!\")&#125;element.addEventListener(\"click\", handler)// 之后element.removeEventListener(\"click\", handler) 命名的函数移除它本身: 12345element.addEventListener('click', function click(e) &#123; if (someCondition) &#123; return e.currentTarget.removeEventListener('click', click); &#125;&#125;); 更好的写法： 123456789101112131415161718192021222324252627function handleEvent (eventName, &#123;onElement, withCallback, useCapture = false&#125; = &#123;&#125;, thisArg) &#123; const element = onElement || document.documentElement function handler (event) &#123; if (typeof withCallback === 'function') &#123; withCallback.call(thisArg, event) &#125; &#125; handler.destroy = function () &#123; return element.removeEventListener(eventName, handler, useCapture) &#125; element.addEventListener(eventName, handler, useCapture) return handler&#125;// 你需要的时候const handleClick = handleEvent('click', &#123; onElement: element, withCallback: (event) =&gt; &#123; console.log('Tada!') &#125;&#125;)// 你想删除它的时候handleClick.destroy()","tags":[]},{"title":"实用的`log`技巧","date":"2019-11-04T02:44:10.453Z","path":"2019/11/04/javascript/2016-03-03-helpful-console-log-hacks/","text":"使用条件断点输出log如果你想当函数每次被调用时都在控制台打印一个值，你可以应用条件断点来实现。打开你的开发工具，找到你准备打印的值所在的函数然后使用如下条件设置一个条件断点： 1console.log(data.value) &amp;&amp; false 条件断点只有在条件运行的结果为true时才会中断页面。所以使用console.log(&#39;foo&#39;) &amp;&amp; false这样的条件，由于你把false放在了AND条件中，所以结果肯定是false。因此这并不会中断页面但是会打印log到控制台。这也可以应用在计算某个函数或回调被调用了多少次上面。 这里有各个平台下设置条件断点的方法：Edge、Chrome、Firefox、Safari。 打印函数到控制台你曾经有过打算打印函数到控制台却不能看到函数的代码的情况吗？最快的方法查看函数的代码是将其与空字符串连接，从而将其强制转换为字符串。 1console.log(funcVariable + '');","tags":[]},{"title":"函数参数内使用解构","date":"2019-11-04T02:44:10.452Z","path":"2019/11/04/javascript/2016-02-12-use-destructuring-in-function-parameters/","text":"大家一定对ES6解构赋值非常熟悉。但是你知道在函数参数里也可以使用它吗？ 123456var sayHello = function(&#123; name, surname &#125;) &#123; console.log(`Hello $&#123;name&#125; $&#123;surname&#125;! How are you?`);&#125;;sayHello(&#123; name: 'John', surname: 'Smith' &#125;)// -&gt; Hello John Smith! How are you? 这对于接收可选参数的函数，是很棒的。对于这种用法，你也可以添加默认参数值来填充调用者没有传递或忘记传递的参数值： 123var sayHello2 = function(&#123; name = \"Anony\", surname = \"Moose\" &#125; = &#123;&#125;) &#123; console.log(`Hello $&#123;name&#125; $&#123;surname&#125;! How are you?`);&#125;; = {}表示此参数需要解构的默认对象是一个{}，以防调用者忘记传值，或传递了一个错误类型（大多情况为后者）。 1234sayHello2()// -&gt; Hello Anony Moose! How are you?sayHello2(&#123; name: \"Bull\" &#125;)// -&gt; Hello Bull Moose! How are you? 参数处理对于普通的解构，如果输入的参数与函数指定的对象参数不符，所有不符的参数都将为undefined，所以你需要增加代码来正确的处理这些情况： 12345678var sayHelloTimes = function(&#123; name, surname &#125;, times) &#123; console.log(`Hello $&#123;name&#125; $&#123;surname&#125;! I've seen you $&#123;times&#125; times before.`);&#125;sayHelloTimes(&#123; name: \"Pam\" &#125;, 5678)// -&gt; Hello Pam undefined! I've seen you 5678 times before.sayHelloTimes(5678)// -&gt; Hello undefined undefined! I've seen you undefined times before. 更糟糕的，如果没有传递需要解构的的参数，将会抛出错误，这可能使你的应用崩溃： 12sayHelloTimes()// -&gt; Uncaught TypeError: Cannot match against 'undefined' or 'null'... 这与访问一个未定义对象的参数基本相似，只是错误类型不太一样。 为解构增加默认参数基本上解决了上面的所有问题： 12345678910var sayHelloTimes2 = function(&#123; name = \"Anony\", surname = \"Moose\" &#125; = &#123;&#125;, times) &#123; console.log(`Hello $&#123;name&#125; $&#123;surname&#125;! I've seen you $&#123;times&#125; times before.`);&#125;;sayHelloTimes2(&#123; name: \"Pam\" &#125;, 5678)// -&gt; Hello Pam Moose! I've seen you 5678 times before.sayHelloTimes2(5678)// -&gt; Hello Anony Moose! I've seen you undefined times before.sayHelloTimes2()// -&gt; Hello Anony Moose! I've seen you undefined times before. 对于= {}，它掩盖了_object_未传递时的情况，但对于个别属性默认值的情形下会抛出异常： 12345678910var sayHelloTimes2a = function(&#123; name = \"Anony\", surname = \"Moose\" &#125;, times) &#123; console.log(`Hello $&#123;name&#125; $&#123;surname&#125;! I've seen you $&#123;times&#125; times before.`);&#125;;sayHelloTimes2a(&#123; name: \"Pam\" &#125;, 5678)// -&gt; Hello Pam Moose! I've seen you 5678 times before.sayHelloTimes2a(5678)// -&gt; Hello Anony Moose! I've seen you undefined times before.sayHelloTimes2a()// -&gt; Uncaught TypeError: Cannot match against 'undefined' or 'null'. 可用性需要注意解构赋值可能在你正在使用的Node.js或浏览器中默认情况下并不可用。对于Node.js，你可以在启动时使用--harmony-destructuring标记开启此特性。","tags":[]},{"title":"预防unapply攻击","date":"2019-11-04T02:44:10.452Z","path":"2019/11/04/javascript/2016-02-11-preventing-unapply-attacks/","text":"重写内置对象的原型方法，外部代码可以通过重写代码达到暴漏和修改已绑定参数的函数。这在es5的方法下使用polyfill时是一个严重的安全问题。 123456789101112131415161718192021// bind polyfill 示例function bind(fn) &#123; var prev = Array.prototype.slice.call(arguments, 1); return function bound() &#123; var curr = Array.prototype.slice.call(arguments, 0); var args = Array.prototype.concat.apply(prev, curr); return fn.apply(null, args); &#125;;&#125;// unapply攻击function unapplyAttack() &#123; var concat = Array.prototype.concat; Array.prototype.concat = function replaceAll() &#123; Array.prototype.concat = concat; // restore the correct version var curr = Array.prototype.slice.call(arguments, 0); var result = concat.apply([], curr); return result; &#125;;&#125; 上面的函数声明忽略了函数bind的prev参数，意味着调用unapplyAttack之后首次调用.concat将会抛出错误。 使用Object.freeze，可以使对象不可变，你可以防止任何内置对象原型方法被重写。 12345678(function freezePrototypes() &#123; if (typeof Object.freeze !== 'function') &#123; throw new Error('Missing Object.freeze'); &#125; Object.freeze(Object.prototype); Object.freeze(Array.prototype); Object.freeze(Function.prototype);&#125;()); 你可以在这里阅读更多关于unapply攻击。","tags":[]},{"title":"变量声明","date":"2019-11-04T02:44:10.452Z","path":"2019/11/04/javascript/2016-02-16-basics-declarations/","text":"下文是JavaScript中声明变量的不同方法。注释与console.log足够说明这里发生了什么： 12345var y, x = y = 1 //== var x; var y; x = y = 1console.log('--&gt; 1:', `x = $&#123;x&#125;, y = $&#123;y&#125;`)// 将会输出//--&gt; 1: x = 1, y = 1 首先，我们只设置了两个变量。并没有很多。 123456789;(() =&gt; &#123; var x = y = 2 // == var x; y = 2; console.log('2.0:', `x = $&#123;x&#125;, y = $&#123;y&#125;`)&#125;)()console.log('--&gt; 2.1:', `x = $&#123;x&#125;, y = $&#123;y&#125;`)// 将会输出//2.0: x = 2, y = 2//--&gt; 2.1: x = 1, y = 2 正如你所看到的，代码只改变了全局的y，因为我们在闭包里并没有声明此变量。 123456789;(() =&gt; &#123; var x, y = 3 // == var x; var y = 3; console.log('3.0:', `x = $&#123;x&#125;, y = $&#123;y&#125;`)&#125;)()console.log('--&gt; 3.1:', `x = $&#123;x&#125;, y = $&#123;y&#125;`)// 将会输出//3.0: x = undefined, y = 3//--&gt; 3.1: x = 1, y = 2 现在我们用var声明了两个变量。意味着他们仅在闭包内有作用。 123456789;(() =&gt; &#123; var y, x = y = 4 // == var x; var y; x = y = 4 console.log('4.0:', `x = $&#123;x&#125;, y = $&#123;y&#125;`)&#125;)()console.log('--&gt; 4.1:', `x = $&#123;x&#125;, y = $&#123;y&#125;`)// 将会输出//4.0: x = 4, y = 4//--&gt; 4.1: x = 1, y = 2 两个变量都使用var声明了而且在之后又给它们赋值。由于local &gt; global，闭包内声明了x和y，意味着闭包内是无法访问全局的x和y的。 12345x = 5 // == x = 5console.log('--&gt; 5:', `x = $&#123;x&#125;, y = $&#123;y&#125;`)// 将会输出//--&gt; 5: x = 5, y = 2 最后一行的结果是很明显的。 你可以在这里测试并看到结果 感谢babel. 更多相关内容请看MDN. 特别感谢@kurtextrem的合作 :)!","tags":[]},{"title":"数组平均值与中值","date":"2019-11-04T02:44:10.452Z","path":"2019/11/04/javascript/2016-02-10-array-average-and-median/","text":"下面的例子都基于如下数组： 1let values = [2, 56, 3, 41, 0, 4, 100, 23]; 要取得平均值，我们需要将数字求和，然后除以values的数目，步骤如下： 取得数组长度(length) 求和(sum) 取得平均值(sum/length) 1234let values = [2, 56, 3, 41, 0, 4, 100, 23];let sum = values.reduce((previous, current) =&gt; current += previous);let avg = sum / values.length;// avg = 28 或者： 12345let values = [2, 56, 3, 41, 0, 4, 100, 23];let count = values.length;values = values.reduce((previous, current) =&gt; current += previous);values /= count;// avg = 28 取得中值的步骤是： 将数组排序 取得中位数 123456let values = [2, 56, 3, 41, 0, 4, 100, 23];values.sort((a, b) =&gt; a - b);let lowMiddle = Math.floor((values.length - 1) / 2);let highMiddle = Math.ceil((values.length - 1) / 2);let median = (values[lowMiddle] + values[highMiddle]) / 2;// median = 13,5 或者使用无符号右移操作符： 1234let values = [2, 56, 3, 41, 0, 4, 100, 23];values.sort((a, b) =&gt; a - b);let median = (values[(values.length - 1) &gt;&gt; 1] + values[values.length &gt;&gt; 1]) / 2// median = 23","tags":[]},{"title":"使用JSON.Stringify","date":"2019-11-04T02:44:10.452Z","path":"2019/11/04/javascript/2016-02-09-using-json-stringify/","text":"假如有一个对象具有参数”prop1”, “prop2”, “prop3”。我们可以通过传递 附加参数 给 JSON.stringify 来选择性地将参数生成字符串，像这样： 123456789101112var obj = &#123; 'prop1': 'value1', 'prop2': 'value2', 'prop3': 'value3'&#125;;var selectedProperties = ['prop1', 'prop2'];var str = JSON.stringify(obj, selectedProperties);// str// &#123;\"prop1\":\"value1\",\"prop2\":\"value2\"&#125; “str” 将只包含选择的参数。 除了传递数组，我们也可以传递函数。 12345678910111213function selectedProperties(key, val) &#123; // the first val will be the entire object, key is empty string if (!key) &#123; return val; &#125; if (key === 'prop1' || key === 'prop2') &#123; return val; &#125; return;&#125; 最后一个参数，可以修改生成字符串的方式。 12345678var str = JSON.stringify(obj, selectedProperties, '\\t\\t');/* str output with double tabs in every line.&#123; \"prop1\": \"value1\", \"prop2\": \"value2\"&#125;*/","tags":[]},{"title":"了解传值机制","date":"2019-11-04T02:44:10.452Z","path":"2019/11/04/javascript/2016-02-13-know-the-passing-mechanism/","text":"理论上，JavaScript通过值传递。它既不是值传递也不是引用传递，具体取决于它的真实场景。要理解传值机制，看一下下面两个实例代码和解释。 实例 11234567891011121314var me = &#123; // 1 'partOf' : 'A Team'&#125;; function myTeam(me) &#123; // 2 me = &#123; // 3 'belongsTo' : 'A Group' &#125;; &#125; myTeam(me); console.log(me); // 4 : &#123;'partOf' : 'A Team'&#125; 在上面的实例里myTeam被调用的时候，JavaScript 传递me对象的引用值，因为它是一个对象。而且调用本身建立了同一个对象的两个独立的引用，（虽然在这里的的命名都是相同的，比如me, 这有些无调行，而且给我们一个这是单个引用的印象）因此，引用变量本身是独立的。 当我们在#3定义了一个新的对象，我们完全改变了myTeam函数内的引用值，这对此函数作用域外的原始对象是没有任何影响的，外作用域的引用仍保留在原始对象上，因此从#4输出去了。 实例 21234567891011var me = &#123; // 1 'partOf' : 'A Team'&#125;; function myGroup(me) &#123; // 2 me.partOf = 'A Group'; // 3&#125; myGroup(me);console.log(me); // 4 : &#123;'partOf' : 'A Group'&#125; 当myGroup调用时，我们将对象me传给函数。但是与实例1的情况不同，我们没有指派me变量到任何新对象，有效的说明了myGroup函数作用域内的对象引用值依旧是原始对象的引用值，而且我们在作用域内修改对象的参数值同样有效的修改了原始对象的参数。因此你得到了#7的输出结果。 所以后面的例子是否说明javascript是引用传递呢？不，并没有。请记住，如果是对象的话，JavaScript将引用按值传递。这种混乱往往发生在我们没有完全理解什么通过引用传递的情况下。这就是确切的原因，有些人更愿意称它为call-by-sharing。 此文最初被作者发表在js-by-examples","tags":[]},{"title":"纯JS监听document是否加载完成","date":"2019-11-04T02:44:10.452Z","path":"2019/11/04/javascript/2016-02-15-detect-document-ready-in-pure-js/","text":"跨浏览器且纯JavaScript检测document是否加载完成的方法是使用readyState. 123if (document.readyState === 'complete') &#123; // 页面已完全加载&#125; 这样可以在document完全加载时监测到…… 123456let stateCheck = setInterval(() =&gt; &#123; if (document.readyState === 'complete') &#123; clearInterval(stateCheck); // document ready &#125;&#125;, 100); 或者使用onreadystatechange 12345document.onreadystatechange = () =&gt; &#123; if (document.readyState === 'complete') &#123; // document ready &#125;&#125;; 使用document.readyState === &#39;interactive&#39;监听DOM是否加载完成。","tags":[]},{"title":"计算数组中的最大值/最小值","date":"2019-11-04T02:44:10.452Z","path":"2019/11/04/javascript/2016-02-14-calculate-the-max-min-value-from-an-array/","text":"内置函数Math.max()和Math.min()可以分别找出参数中的最大值和最小值。 12Math.max(1, 2, 3, 4); // 4Math.min(1, 2, 3, 4); // 1 这些函数对于数字组成的数组是不能用的。但是，这有一些类似地方法。 Function.prototype.apply()让你可以使用提供的this与参数组成的_数组(array)_来调用函数。 123var numbers = [1, 2, 3, 4];Math.max.apply(null, numbers) // 4Math.min.apply(null, numbers) // 1 给apply()第二个参数传递numbers数组，等于使用数组中的所有值作为函数的参数。 一个更简单的，基于ES2015的方法来实现此功能，是使用展开运算符. 123var numbers = [1, 2, 3, 4];Math.max(...numbers) // 4Math.min(...numbers) // 1 此运算符使数组中的值在函数调用的位置展开。","tags":[]},{"title":"数组去重","date":"2019-11-04T02:44:10.451Z","path":"2019/11/04/javascript/2016-02-06-deduplicate-an-array/","text":"原始变量如果一个数组只包含原始变量，我们可以使用filter和indexOf方法将其去重： 12345var deduped = [ 1, 1, 'a', 'a' ].filter(function (el, i, arr) &#123; return arr.indexOf(el) === i;&#125;);console.log(deduped); // [ 1, 'a' ] ES2015我们可以使用箭头函数使写法更简明： 123var deduped = [ 1, 1, 'a', 'a' ].filter( (el, i, arr) =&gt; arr.indexOf(el) === i);console.log(deduped); // [ 1, 'a' ] 但是根据Sets和from方法的介绍，我们可以更简明的实现。 123var deduped = Array.from( new Set([ 1, 1, 'a', 'a' ]) );console.log(deduped); // [ 1, 'a' ] Objects当元素为对象(Object)时，我们就不能用这种办法了，因为对象存储的是引用而原始变量存储的是值。 123451 === 1 // true'a' === 'a' // true&#123; a: 1 &#125; === &#123; a: 1 &#125; // false 因此我们需要改变一下我们的实现方法，使用哈希表。 12345678910111213141516171819function dedup(arr) &#123; var hashTable = &#123;&#125;; return arr.filter(function (el) &#123; var key = JSON.stringify(el); var match = Boolean(hashTable[key]); return (match ? false : hashTable[key] = true); &#125;);&#125;var deduped = dedup([ &#123; a: 1 &#125;, &#123; a: 1 &#125;, [ 1, 2 ], [ 1, 2 ]]);console.log(deduped); // [ &#123;a: 1&#125;, [1, 2] ] 因为哈希表在Javascript里是一个简单的Object，它的key永远是String类型。这意味着我们不能区分字符串和数字表示的相同的值，如1和&#39;1&#39;。 123456var hashTable = &#123;&#125;;hashTable[1] = true;hashTable['1'] = true;console.log(hashTable); // &#123; '1': true &#125; 然而，因为我们使用的JSON.stringify，String类型的key将会被存储为一个字符串值，这样hashTable的key就唯一了。 123456var hashTable = &#123;&#125;;hashTable[JSON.stringify(1)] = true;hashTable[JSON.stringify('1')] = true;console.log(hashTable); // &#123; '1': true, '\\'1\\'': true &#125; 这意味着相同的值，但不同类型的元素，将以原来的格式保留。 123456789101112var deduped = dedup([ &#123; a: 1 &#125;, &#123; a: 1 &#125;, [ 1, 2 ], [ 1, 2 ], 1, 1, '1', '1']);console.log(deduped); // [ &#123;a: 1&#125;, [1, 2], 1, '1' ] 阅读材料函数 filter indexOf from JSON.stringify ES2015 箭头函数 Set Stack overflow remove duplicates from array","tags":[]},{"title":"Javascript多维数组扁平化","date":"2019-11-04T02:44:10.451Z","path":"2019/11/04/javascript/2016-02-07-flattening-multidimensional-arrays-in-javascript/","text":"下面是将多位数组转化为单一数组的三种不同方法。 对于此数组： 1var myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]]; 我们需要的结果是： 1[1, 2, 3, 4, 5, 6, 7, 8, 9] 解决方案1：使用concat()和apply()12var myNewArray = [].concat.apply([], myArray);// [1, 2, 3, 4, 5, 6, 7, 8, 9] 解决方案2：使用reduce()1234var myNewArray = myArray.reduce(function(prev, curr) &#123; return prev.concat(curr);&#125;);// [1, 2, 3, 4, 5, 6, 7, 8, 9] 解决方案3：1234567var myNewArray3 = [];for (var i = 0; i &lt; myArray.length; ++i) &#123; for (var j = 0; j &lt; myArray[i].length; ++j) myNewArray3.push(myArray[i][j]);&#125;console.log(myNewArray3);// [1, 2, 3, 4, 5, 6, 7, 8, 9] 在这里看一下三种逻辑的实际作用。 方案四：使用 ES6 的展开运算符123var myNewArray4 = [].concat(...myArray);console.log(myNewArray4);// [1, 2, 3, 4, 5, 6, 7, 8, 9] 在这里 查看这四种方法 对于无限嵌套的数组请使用 Lodash 的 flattenDeep()。 如果你担心性能问题的话，这里 有一个测试让你确认他们是如何执行的。 对于较大的数组试一下Underscore的flatten(). 如果你对性能好奇，这里有一个测试。","tags":[]},{"title":"Map()的营救；使对象属性有顺序","date":"2019-11-04T02:44:10.451Z","path":"2019/11/04/javascript/2016-02-01-map-to-the-rescue-adding-order-to-object-properties/","text":"对象属性顺序 一个对象是一个Object类型的实例。它是由一些未排序的元素组成的集合，其中包含了原始变量，对象，和函数。一个对象的属性所对应的函数被称为方法。ECMAScript 实际看一下 123456789101112131415var myObject = &#123; z: 1, '@': 2, b: 3, 1: 4, 5: 5&#125;;console.log(myObject) // Object &#123;1: 4, 5: 5, z: 1, @: 2, b: 3&#125;for (item in myObject) &#123;...// 1// 5// z// @// b 因为技术实现，每个浏览器在排序时都有自己的规则，顺序是不确定的。 怎么解决呢?Map使用ES6的新特性Map。Map 对象以插入的顺序遍历元素。for...of循环为每一次循环返回一个[key, value]数组。 12345678910var myObject = new Map();myObject.set('z', 1);myObject.set('@', 2);myObject.set('b', 3);for (var [key, value] of myObject) &#123; console.log(key, value);...// z 1// @ 2// b 3 攻克老浏览器Mozilla 建议: 所以，如果过你想在跨浏览器环境中模拟一个有序的关联数组，你要么使用两个分开的数组（一个保存key，另一个保存value）,要么构建一个单属性对象(single-property objects)的数组。 12345678// 使用分开的数组var objectKeys = [z, @, b, 1, 5];for (item in objectKeys) &#123; myObject[item]...// 构建一个单属性对象(single-property objects)的数组var myData = [&#123;z: 1&#125;, &#123;'@': 2&#125;, &#123;b: 3&#125;, &#123;1: 4&#125;, &#123;5: 5&#125;];","tags":[]},{"title":"扩展插件中观察DOM的变化","date":"2019-11-04T02:44:10.451Z","path":"2019/11/04/javascript/2016-02-05-observe-dom-changes/","text":"MutationObserver是监听DOM变化与当元素变化时做适当操作的一个解决方法。在下面的例子中我们使用计时器模拟了内容的动态加载，第一个元素”target”创建后，创建”subTarget”。在扩展中的代码，rootObserver首先开始工作，直到targetElement被创建后rootObserver停止，然后elementObserver开始工作。这个级联观测可以在发现subTargetElement时提醒你。这个方法在为动态加载内容的网站开发扩展插件时，是很有用的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const observeConfig = &#123; attributes: true, childList: true, characterData: true, subtree: true&#125;;function initExtension(rootElement, targetSelector, subTargetSelector) &#123; var rootObserver = new MutationObserver(function(mutations) &#123; console.log(\"Inside root observer\"); targetElement = rootElement.querySelector(targetSelector); if (targetElement) &#123; rootObserver.disconnect(); var elementObserver = new MutationObserver(function(mutations) &#123; console.log(\"Inside element observer\") subTargetElement = targetElement.querySelector(subTargetSelector); if (subTargetElement) &#123; elementObserver.disconnect(); console.log(\"subTargetElement found!\") &#125; &#125;) elementObserver.observe(targetElement, observeConfig); &#125; &#125;) rootObserver.observe(rootElement, observeConfig);&#125;(function() &#123; initExtension(document.body, \"div.target\", \"div.subtarget\") setTimeout(function() &#123; del = document.createElement(\"div\"); del.innerHTML = \"&lt;div class='target'&gt;target&lt;/div&gt;\" document.body.appendChild(del) &#125;, 3000); setTimeout(function() &#123; var el = document.body.querySelector('div.target') if (el) &#123; del = document.createElement(\"div\"); del.innerHTML = \"&lt;div class='subtarget'&gt;subtarget&lt;/div&gt;\" el.appendChild(del) &#125; &#125;, 5000);&#125;)()","tags":[]},{"title":"仅用一行生成`[0, 1, ..., N-1]`数列","date":"2019-11-04T02:44:10.451Z","path":"2019/11/04/javascript/2016-02-02-create-range-0...n-easily-using-one-line/","text":"使用下面一行代码，我们就可以生成0…(N-1)数列。 方法1 (需要 ES5)1Array.apply(null, &#123;length: N&#125;).map(Function.call, Number); 简要说明 Array.apply(null, {length: N}) 返回一个由undefined填充的长度为N的数组(例如 A = [undefined, undefined, ...])。 A.map(Function.call, Number) 返回一个长度为N的数组，它的索引为I的元素为Function.call.call(Number, undefined, I, A)的结果。 Function.call.call(Number, undefined, I, A)可转化为Number(I)，正好就是I。 结果为：[0, 1, ..., N-1]。 更全面的介绍，请看这里. 方法2 (需要 ES6)这里用到了Array.from https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from 1Array.from(new Array(N),(val,index)=&gt;index); 简要说明 A = new Array(N) 返回一个有N个_小孔_的数组 (例如 A = [,,,...], 但是对于x in 0...N-1时A[x] = undefined)。 F = (val,index)=&gt;index 即 function F (val, index) { return index; }。 Array.from(A, F) 返回一个长度为N的数组，它的索引为I的元素为F(A[I], I)的结果，也就是I。 结果为：[0, 1, ..., N-1]。 One More Thing如果你需要[1, 2, …, N]序列， 方法1 可改为： 123Array.apply(null, &#123;length: N&#125;).map(function(value, index)&#123; return index + 1;&#125;); 方法2可改为： 1Array.from(new Array(N),(val,index)=&gt;index+1);","tags":[]},{"title":"实现异步循环","date":"2019-11-04T02:44:10.451Z","path":"2019/11/04/javascript/2016-02-03-implementing-asynchronous-loops/","text":"让我们试着写一个异步方法，每秒打印一次循环的索引值。 12345for (var i=0; i&lt;5; i++) &#123; setTimeout(function()&#123; console.log(i); &#125;, 1000 * (i+1));&#125; 如上程序的输出为： 12345&gt; 5&gt; 5&gt; 5&gt; 5&gt; 5 这明显是有问题的。 原因 每次时间结束(timeout)都指向原始的i，而并非它的拷贝。所以，for循环使i增长到5，之后timeout运行并调用了当前i的值（也就是5）。 好吧，这个问题看起来很简单。最直接的解决方法是将循环的索引缓存在一个临时变量里。 123456for (var i=0; i&lt;5; i++) &#123; var temp = i; setTimeout(function()&#123; console.log(temp); &#125;, 1000 * (i+1));&#125; 但是再次运行，如上的程序输出为： 12345&gt; 4&gt; 4&gt; 4&gt; 4&gt; 4 这仍然有问题，这是因为并不存在块作用域，而且变量的声明被提升到了作用域顶端。实际上，如上代码和下面是一样的： 1234567var temp;for (var i=0; i&lt;5; i++) &#123; temp = i; setTimeout(function()&#123; console.log(temp); &#125;, 1000 * (i+1));&#125; 解决方法 有几个不同的方式可以拷贝i。最普通且常用方法是通过声明函数来建立一个闭包，并将i传给此函数。我们这里使用了自调用函数。 1234567for (var i=0; i&lt;5; i++) &#123; (function(num)&#123; setTimeout(function()&#123; console.log(num); &#125;, 1000 * (i+1)); &#125;)(i); &#125; 在JavaScript里，参数是按值传递给函数的。像Number、Date和String这些原始类型为基本复制。当你们在一个函数内改变它的值，并不影响外面的作用域。但Object类型不一样：如果你在函数内部修改了它的参数，将会影响到所有包含该Object的作用域内它的参数。 另一种方法是使用let。在ES6中的let关键字是可以实现的，它和var不一样，因为它支持块作用域的。 123456for (let i=0; i&lt;5; i++) &#123; var temp = i; setTimeout(function()&#123; console.log(i); &#125;, 1000 * (i+1));&#125;","tags":[]},{"title":"Javascript高级特性","date":"2019-11-04T02:44:10.451Z","path":"2019/11/04/javascript/2016-02-08-advanced-properties/","text":"在Javascript里配置对象属性是可以实现的，比如将一个参数设为伪私有或者只读。这个特性从ECMAScript 5.1开始就可以使用了，因此近来的浏览器都是支持的。要实现这些功能，你需要使用Object的原型方法defineProperty，像这样： 12345678var a = &#123;&#125;;Object.defineProperty(a, 'readonly', &#123; value: 15, writable: false&#125;);a.readonly = 20;console.log(a.readonly); // 15 语法如下： 1Object.defineProperty(dest, propName, options); 或者定义多个： 1234Object.defineProperties(dest, &#123; propA: optionsA, propB: optionsB, //...&#125;); options包含如下的属性： value: 如果参数不是getter（请看下文），value是必须的。{a: 12} === Object.defineProperty(obj, &#39;a&#39;, {value: 12}) writable: 将参数设为只读。需要注意的是如果参数是嵌套对象，它的元素仍是能可修改的。 enumerable: 将参数设为隐藏。这意味着for ... of循环和stringify的结果里不会包含这些参数，但是这个参数还是存在的。提示：这并不意味着参数是私有的！他依旧可以从外界访问，只是意味着不会被打印。 configurable: 将属性设置为不能更改，比如：防止参数被删除或重新定义。如果此对象是一个嵌套对象，他的参数依旧是可配置的。 所以如果想创建私有静态变量，你可以这样定义： 1Object.defineProperty(obj, 'myPrivateProp', &#123;value: val, enumerable: false, writable: false, configurable: false&#125;); 除了配置属性，由于defineProperty第二个参数是字符串，所以允许我们定义动态变量(defineProperty)。例如，我们可以说我们要根据一些外部配置创建一个属性： 1234567891011var obj = &#123; getTypeFromExternal(): true // illegal in ES5.1&#125;;Object.defineProperty(obj, getTypeFromExternal(), &#123;value: true&#125;); // ok// For the example sake, ES6 introduced a new syntax:var obj = &#123; [getTypeFromExternal()]: true&#125;; 还没有结束！高级特性允许我们创建getter和setter，就像其他面向对象(OOP)语言！这种情况下，我们不能使用writable、enumerable和configurable参数，而是： 12345678910111213function Foobar () &#123; var _foo; // true private property Object.defineProperty(obj, 'foo', &#123; get: function () &#123; return _foo; &#125; set: function (value) &#123; _foo = value &#125; &#125;);&#125;;var foobar = new Foobar();foobar.foo; // 15foobar.foo = 20; // _foo = 20 除了封装与先进的访问器这些明显的优点，你还发现我们并没有“调用”getter，而是不需要使用小括号直接“取得”了属性！这太棒了！例如，我们可以想象我们有一个多层嵌套对象，像这样： 1var obj = &#123;a: &#123;b: &#123;c: [&#123;d: 10&#125;, &#123;d: 20&#125;] &#125; &#125; &#125;; 现在我们不需要调用a.b.c[0].d（其中某个属性可能是undefined且抛出错误），我们可以创建一个别名： 12345Object.defineProperty(obj, 'firstD', &#123; get: function () &#123; return a &amp;&amp; a.b &amp;&amp; a.b.c &amp;&amp; a.b.c[0] &amp;&amp; a.b.c[0].d &#125;&#125;);console.log(obj.firstD); // 10 提示如果你定义了getter而没有定义setter却仍要给它赋值，你将会得到一个错误。这在使用像$.extend或_.merge这样的辅助方法时是尤为重要的。要小心！ 链接 defineProperty Defining properties in JavaScript","tags":[]},{"title":"赋值技巧","date":"2019-11-04T02:44:10.451Z","path":"2019/11/04/javascript/2016-02-04-assignment-shorthands/","text":"赋值是很常见的。有时候打字对于我们这些“懒惰的程序员”来说是很费时间的。所以，我们可以使用一些小把戏来使我们的代码更清楚更简单。 这类似于使用： 12345678910x += 23; // x = x + 23;y -= 15; // y = y - 15;z *= 10; // z = z * 10;k /= 7; // k = k / 7;p %= 3; // p = p % 3;d **= 2; // d = d ** 2;m &gt;&gt;= 2; // m = m &gt;&gt; 2;n &lt;&lt;= 2; // n = n &lt;&lt; 2;n ++; // n = n + 1;n --; n = n - 1; ++ 与 -- 操作符对于++操作符有些特殊。最好用下面的例子解释一下： 123var a = 2;var b = a++;// 现在 a == 3 b == 2 a++做了如下工作： 返回a的值 a增加1 但是如果我们想让值先增加呢？这也很容易： 123var a = 2;var b = ++a;// 现在a和b都是3 看明白了吗？我将操作符放在了参数_前面_。 --操作符除了使值减小外，其他功能是类似的。 If-else (使用三元运算符)我们平时会这样写： 12345var newValue;if(value &gt; 10) newValue = 5;else newValue = 2; 我们可以使用三元运算符是它更简便： 1var newValue = (value &gt; 10) ? 5 : 2; 检测Null、Undefined、空123if (variable1 !== null || variable1 !== undefined || variable1 !== '') &#123; var variable2 = variable1;&#125; 简便写法： 1var variable2 = variable1 || ''; P.S.：如果variable1是一个数字，则先检查他是否为0。 对象数组表示法不要用： 123var a = new Array();a[0] = \"myString1\";a[1] = \"myString2\"; 使用： 1var a = [\"myString1\", \"myString2\"]; 关联数组不要用： 123var skillSet = new Array();skillSet['Document language'] = 'HTML5';skillSet['Styling language'] = 'CSS3'; 使用： 1234var skillSet = &#123; 'Document language' : 'HTML5', 'Styling language' : 'CSS3'&#125;;","tags":[]},{"title":"柯里化(currying)与部分应用(partial application)","date":"2019-11-04T02:44:10.450Z","path":"2019/11/04/javascript/2016-01-28-curry-vs-partial-application/","text":"柯里化(currying) 柯里化是使一个函数 f: X * Y -&gt; R 转变为 f’: X -&gt; (Y -&gt; R) 与用两个参数调用f不同，我们用一个参数运行f’。返回的结果是一个函数，然后用第二个参数调用此函数，得到结果。 如此，如果未柯里化的函数f这样调用 f(3,5) 柯里化后的函数f’是这样调用的 f(3)(5) 比如:未柯里化的函数add() 123456function add(x, y) &#123; return x + y;&#125;add(3, 5); // returns 8 柯里化后的add() 1234567function addC(x) &#123; return function (y) &#123; return x + y; &#125;&#125;addC(3)(5); // returns 8 柯里化的规则 柯里化将一个二元函数，转变为一元函数，这个函数将返回另一个一元函数。 curry: (X × Y → R) → (X → (Y → R)) Javascript Code: 1234567function curry(f) &#123; return function(x) &#123; return function(y) &#123; return f(x, y); &#125; &#125;&#125; 部分应用(partial application) 部分应用将一个函数 f: X * Y -&gt; R 的第一个参数固定而产生一个新的函数 f`: Y -&gt; R f’与f不同，只需要填写第二个参数，这也是f’比f少一个参数的原因。 比如：将函数add的第一个参数绑定为5来产生函数plus5。 12345function plus5(y) &#123; return 5 + y;&#125;plus5(3); // returns 8 部分应用的规则 部分应用使用一个二元函数和一个值产生了一个一元函数。 partApply : ((X × Y → R) × X) → (Y → R) Javascript Code: 12345function partApply(f, x) &#123; return function(y) &#123; return f(x, y); &#125;&#125;","tags":[]},{"title":"避免修改和传递`arguments`给其他方法 — 影响优化","date":"2019-11-04T02:44:10.450Z","path":"2019/11/04/javascript/2016-01-31-avoid-modifying-or-passing-arguments-into-other-functions—it-kills-optimization/","text":"背景在JavaScript的方法里，arguments参数可以让你访问传递给该方法的所有参数。arguments是一个类数组对象；arguments可是使用数组标记访问，而且它有length参数，但是它没有filter、map和forEach这样内建到数组内的方法。因此，如下代码是一个非常常见的将arguments转换为数组的办法： 1var args = Array.prototype.slice.call(arguments); 将arguments传递给Array原型(prototype)上的slice方法；slice方法返回一个对arguments浅复制后的数组对象。更短的写法： 1var args = [].slice.call(arguments); 在这里，简单的调用了空数组的slice方法，而没有从Array的原型(prototype)上调用。 系统优化不幸的是，传递arguments给任何参数，将导致Chrome和Node中使用的V8引擎跳过对其的优化，这也将使性能相当慢。看一下这篇文章optimization killers。传递arguments给任何方法被称为leaking arguments。 如果你想用一个包含参数(arguments)的数组，你需要求助于这个办法： 1234var args = new Array(arguments.length);for(var i = 0; i &lt; args.length; ++i) &#123; args[i] = arguments[i];&#125; 没错，这很啰嗦，但是在生产环境中的代码里，为了系统性能优化，这是值得的。","tags":[]},{"title":"转换为数字的更快方法","date":"2019-11-04T02:44:10.450Z","path":"2019/11/04/javascript/2016-01-23-converting-to-number-fast-way/","text":"将字符串转换为数字是极为常见的。最简单和快速的方法(jsPref)+(加号) 来实现。 123var one = '1';var numberOne = +one; // Number 1 你也可以用-(减号)将其转化为负数值。 123var one = '1';var negativeNumberOne = -one; // Number -1","tags":[]},{"title":"使用 === 而不是 ==","date":"2019-11-04T02:44:10.450Z","path":"2019/11/04/javascript/2016-01-24-use_===_instead_of_==/","text":"== (或者 !=) 操作在需要的情况下自动进行了类型转换。=== (或 !==)操作不会执行任何转换。===在比较值和类型时，可以说比==更快(jsPref)。 1234567891011[10] == 10 // 为 true[10] === 10 // 为 false'10' == 10 // 为 true'10' === 10 // 为 false [] == 0 // 为 true [] === 0 // 为 false '' == false // 为 true 但 true == \"a\" 为false '' === false // 为 false","tags":[]},{"title":"过滤并排序字符串列表","date":"2019-11-04T02:44:10.450Z","path":"2019/11/04/javascript/2016-01-26-filtering-and-sorting-a-list-of-strings/","text":"你可能有一个很多名字组成的列表，需要过滤掉重复的名字并按字母表将其排序。 在我们的例子里准备用不同版本语言的JavaScript 保留字的列表，但是你能发现，有很多重复的关键字而且它们并没有按字母表顺序排列。所以这是一个完美的字符串列表(数组)来测试我们的JavaScript小知识。 1var keywords = ['do', 'if', 'in', 'for', 'new', 'try', 'var', 'case', 'else', 'enum', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'false', 'super', 'throw', 'while', 'delete', 'export', 'import', 'return', 'switch', 'typeof', 'default', 'extends', 'finally', 'continue', 'debugger', 'function', 'do', 'if', 'in', 'for', 'int', 'new', 'try', 'var', 'byte', 'case', 'char', 'else', 'enum', 'goto', 'long', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'false', 'final', 'float', 'short', 'super', 'throw', 'while', 'delete', 'double', 'export', 'import', 'native', 'public', 'return', 'static', 'switch', 'throws', 'typeof', 'boolean', 'default', 'extends', 'finally', 'package', 'private', 'abstract', 'continue', 'debugger', 'function', 'volatile', 'interface', 'protected', 'transient', 'implements', 'instanceof', 'synchronized', 'do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case', 'else', 'enum', 'eval', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'false', 'super', 'throw', 'while', 'yield', 'delete', 'export', 'import', 'public', 'return', 'static', 'switch', 'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue', 'debugger', 'function', 'arguments', 'interface', 'protected', 'implements', 'instanceof', 'do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case', 'else', 'enum', 'eval', 'null', 'this', 'true', 'void', 'with', 'await', 'break', 'catch', 'class', 'const', 'false', 'super', 'throw', 'while', 'yield', 'delete', 'export', 'import', 'public', 'return', 'static', 'switch', 'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue', 'debugger', 'function', 'arguments', 'interface', 'protected', 'implements', 'instanceof']; 因为我们不想改变我们的原始列表，所以我们准备用高阶函数叫做filter，它将基于我们传递的回调方法返回一个新的过滤后的数组。回调方法将比较当前关键字在原始列表里的索引和新列表中的索引，仅当索引匹配时将当前关键字push到新数组。 最后我们准备使用sort方法排序过滤后的列表，sort只接受一个比较方法作为参数，并返回按字母表排序后的列表。 1234567var filteredAndSortedKeywords = keywords .filter(function (keyword, index) &#123; return keywords.lastIndexOf(keyword) === index; &#125;) .sort(function (a, b) &#123; return a &lt; b ? -1 : 1; &#125;); 在ES6 (ECMAScript 2015)版本下使用箭头函数看起来更简单: 123const filteredAndSortedKeywords = keywords .filter((keyword, index) =&gt; keywords.lastIndexOf(keyword) === index) .sort((a, b) =&gt; a &lt; b ? -1 : 1); 这是最后过滤和排序后的JavaScript保留字列表： 123console.log(filteredAndSortedKeywords);// ['abstract', 'arguments', 'await', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'double', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'final', 'finally', 'float', 'for', 'function', 'goto', 'if', 'implements', 'import', 'in', 'instanceof', 'int', 'interface', 'let', 'long', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'short', 'static', 'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var', 'void', 'volatile', 'while', 'with', 'yield'] 感谢@nikshulipa、@kirilloid、@lesterzone、@tracker1、@manuel_del_pozo所有的回复与建议！","tags":[]},{"title":"使用立即执行函数表达式","date":"2019-11-04T02:44:10.450Z","path":"2019/11/04/javascript/2016-01-25-Using-immediately-invoked-function-expression/","text":"立即执行函数表达式( IIFE - immediately invoked function expression)是一个立即执行的匿名函数表达式，它在Javascript中有一些很重要的用途。 12345(function() &#123; // Do something​ &#125;)() 这是一个立即执行的匿名函数表达式，它在有JavaScript一些特别重要的用途。 两对括号包裹着一个匿名函数，使匿名函数变成了一个函数表达式。于是，我们现在拥有了一个未命名的函数表达式，而不是一个全局作用域下或在任何地方定义的的简单函数。 类似地，我们也可以创建一个命名过的立即执行函数表达式： 123456(someNamedFunction = function(msg) &#123; console.log(msg || \"Nothing for today !!\") &#125;) (); // 输出 --&gt; Nothing for today !!​​someNamedFunction(\"Javascript rocks !!\"); // 输出 --&gt; Javascript rocks !!someNamedFunction(); // 输出 --&gt; Nothing for today !!​ 更多内容, 请参考下面链接 - 链接 1 链接 2 效率:jsPerf","tags":[]},{"title":"JS中的短路求值","date":"2019-11-04T02:44:10.450Z","path":"2019/11/04/javascript/2016-01-27-short-circuit-evaluation-in-js/","text":"短路求值是说, 只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值：当AND(&amp;&amp;)的第一个运算数的值为false时，其结果必定为false；当OR(||)的第一个运算数为true时，最后结果必定为true。 对于下面的test条件和isTrue与isFalse方法 1234567var test = true;var isTrue = function()&#123; console.log('Test is true.');&#125;;var isFalse = function()&#123; console.log('Test is false.');&#125;; 使用逻辑与 - &amp;&amp;. 12345678// 普通的if语句if(test)&#123; isTrue(); // Test is true&#125;// 上面的语句可以使用 '&amp;&amp;' 写为：( test &amp;&amp; isTrue() ); // Test is true 使用逻辑或 - ||. 123456test = false;if(!test)&#123; isFalse(); // Test is false.&#125;( test || isFalse()); // Test is false. 逻辑或可以用来给参数设置默认值。 123456function theSameOldFoo(name)&#123; name = name || 'Bar' ; console.log(\"My best friend's name is \" + name);&#125;theSameOldFoo(); // My best friend's name is BartheSameOldFoo('Bhaskar'); // My best friend's name is Bhaskar 逻辑与可以用来避免调用undefined参数的属性时报错例如:- 12345678910111213var dog = &#123; bark: function()&#123; console.log('Woof Woof'); &#125;&#125;;// 调用 dog.bark();dog.bark(); // Woof Woof.// 但是当dog未定义时，dog.bark() 将会抛出\"Cannot read property 'bark' of undefined.\" 错误// 防止这种情况，我们可以使用 &amp;&amp;.dog&amp;&amp;dog.bark(); // This will only call dog.bark(), if dog is defined.","tags":[]},{"title":"将truthy/falsy转换为布尔值","date":"2019-11-04T02:44:10.450Z","path":"2019/11/04/javascript/2016-01-30-converting-truthy-falsy-values-to-boolean/","text":"你可以使用!!操作符将truthy或falsy值转换为布尔值。 12345678910!!\"\" // false!!0 // false!!null // false!!undefined // false!!NaN // false!!\"hello\" // true!!1 // true!!&#123;&#125; // true!![] // true","tags":[]},{"title":"运用存储加速递归 Speed up recursive functions with memoization","date":"2019-11-04T02:44:10.450Z","path":"2019/11/04/javascript/2016-01-29-speed-up-recursive-functions-with-memoization/","text":"大家对斐波那契(Fibonacci)数列都很熟悉。我们可以再20秒内写出下面这样一个方法。 123var fibonacci = function(n)&#123; return n &lt; 2 ? n : fibonacci(n-1) + fibonacci(n-2);&#125; 它可以运行，但并不高效。它做了太多重复的运算，我们可以通过存储这些运算结果来使其加速。 1234567891011var fibonacci = (function() &#123; var cache = [0, 1]; // cache the value at the n index return function(n) &#123; if (cache[n] === undefined) &#123; for (var i = cache.length; i &lt;= n; ++i) &#123; cache[i] = cache[i-1] + cache[i-2]; &#125; &#125; return cache[n]; &#125;&#125;)() 我们也可以定义一个高阶函数，它接收一个方法作为参数，返回一个该方法运用存储后的新方法。 12345678var memoize = function(func)&#123; var cache = &#123;&#125;; return function()&#123; var key = Array.prototype.slice.call(arguments).toString(); return key in cache ? cache[key] : (cache[key] = func.apply(this,arguments)); &#125;&#125;fibonacci = memoize(fibonacci); ES6版本的memoize函数如下： 12345678var memoize = function(func)&#123; const cache = &#123;&#125;; return (...args) =&gt; &#123; const key = [...args].toString(); return key in cache ? cache[key] : (cache[key] = func(...args)); &#125;&#125;fibonacci = memoize(fibonacci); 我们可以将memoize()用在很多其他地方 GCD(最大公约数) 1234567var gcd = memoize(function(a,b)&#123; var t; if (a &lt; b) t=b, b=a, a=t; while(b != 0) t=b, b = a%b, a=t; return a;&#125;)gcd(27,183); //=&gt; 3 阶乘运算 1234var factorial = memoize(function(n) &#123; return (n &lt;= 1) ? 1 : n * factorial(n-1);&#125;)factorial(5); //=&gt; 120","tags":[]},{"title":"清空数组的两种方法","date":"2019-11-04T02:44:10.449Z","path":"2019/11/04/javascript/2016-01-22-two-ways-to-empty-an-array/","text":"如果你定义了一个数组，然后你想清空它。通常，你会这样做： 1234567// 定义一个数组var list = [1, 2, 3, 4];function empty() &#123; //清空数组 list = [];&#125;empty(); 但是，这有一个效率更高的方法来清空数组。你可以这样写: 123456var list = [1, 2, 3, 4];function empty() &#123; //empty your array list.length = 0;&#125;empty(); list = [] 将一个新的数组的引用赋值给变量，其他引用并不受影响。这意味着以前数组的内容被引用的话将依旧存在于内存中，这将导致内存泄漏。 list.length = 0 删除数组里的所有内容，也将影响到其他引用。 然而，如果你复制了一个数组（A 和 Copy-A），如果你用list.length = 0清空了它的内容，复制的数组也会清空它的内容。 考虑一下将会输出什么： 123456789var foo = [1,2,3];var bar = [1,2,3];var foo2 = foo;var bar2 = bar;foo = [];bar.length = 0;console.log(foo, bar, foo2, bar2);//[] [] [1, 2, 3] [] 更多内容请看Stackoverflow：difference-between-array-length-0-and-array","tags":[]},{"title":"向回调方法传递参数","date":"2019-11-04T02:44:10.449Z","path":"2019/11/04/javascript/2016-01-16-passing-arguments-to-callback-functions/","text":"通常下，你并不能给回调函数传递参数。 比如: 12345function callback() &#123; console.log('Hi human');&#125;document.getElementById('someelem').addEventListener('click', callback); 你可以借助Javascript闭包的优势来传递参数给回调函数。看这个例子: 12345678function callback(a, b) &#123; return function() &#123; console.log('sum = ', (a+b)); &#125;&#125;var x = 1, y = 2;document.getElementById('someelem').addEventListener('click', callback(x, y)); 什么是闭包?闭包是指函数有自由独立的变量。换句话说，定义在闭包中的函数可以“记忆”它创建时候的环境。想了解更多请参考MDN的文档。 这种方法使参数x和y在回调方法被调用时处于其作用域内。 另一个办法是使用bind方法。比如: 12345var alertText = function(text) &#123; alert(text);&#125;;document.getElementById('someelem').addEventListener('click', alertText.bind(this, 'hello')); 两种方法之间有着微小的性能差异,请看jsperf.","tags":[]},{"title":"快速（但危险）的取整方法","date":"2019-11-04T02:44:10.449Z","path":"2019/11/04/javascript/2016-01-18-rounding-the-fast-way/","text":"本条小知识关于性能… 你曾遇到过双波浪线~~操作符吗？它也被称为“双按位非”操作符。你通常可以使用它作为代替Math.trunc()的更快的方法。为什么呢？ 一个按位非操作符~首先将输入input截取为32位，然后将其转换为-(input+1)。因此双按位非操作符将输入转换为-(-(input + 1)+1)，使其成为一个趋向于0取整的好工具。对于数字的输入，它很像Math.trunc()。失败时返回0,这可能在解决Math.trunc()转换错误返回NaN时是一个很好的替代。 1234567// 单个 ~console.log(~1337) // -1338// 数字输入console.log(~~47.11) // -&gt; 47console.log(~~1.9999) // -&gt; 1console.log(~~3) // -&gt; 3 然而, 尽管~~可能有更好的性能，有经验的程序员通常坚持使用Math.trunc()。要明白为什么，这里有一个关于此操作符的冷静分析。 适用的情况当CPU资源很珍贵时~~可能在各平台上都比Math.trunc()快，但是你应该在你所关心的所有平台上测试这种猜想。同样，你通常需要执行数百万这样的操作来看看在运行时有没有明显的影响。 当不需要关心代码清晰度时如果你想迷惑其他人，或者想在minifier/uglifier时取得更大功效，这是一种相对廉价的方式。 禁用的情况当你的代码需要维护时代码可读性始终是最重要的。无论你工作在一个团队，或是贡献给开源仓库，或是单飞。正如名言所说： Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live.(写代码时，要始终认为一个有暴力倾向并知道你住在哪里的人会最终维护你的代码。) For a solo programmer, that psychopath is inevitably “you in six months”.（这句不会翻译……） 当你忘记~~永远趋向于0时新手程序员或许更关注~~的聪明之处，却忘记了“只去掉小数部分”的意义。这在将浮点数转换为数组索引或关联有序的值时很容易导致差一错误 ，这时明显需要一个不同的取整方法。 （代码可读性不高往往会导致此问题） 打个比方，如果你想得到离一个数“最近的整数”，你应该用Math.round()而不是~~，但是由于程序员的惰性和每次使用需要敲10个键的事实，人类的手指往往会战胜冷冷的逻辑，导致错误的结果。 相比之下，Math.xyz()（举例）函数的名字清楚的传达了它们的作用，减少了可能出现的意外的错误。 当处理大数时因为~首先将数组转换为32位，~~的结果伪值在 &plusmn;2.15*10^12左右。如果你没有明确的检查输入值的范围，当转换的值最终与原始值有很大差距时，用户就可能触发未知的行为： 1234a = 2147483647.123 // 比32位最大正数，再多一点console.log(~~a) // -&gt; 2147483647 (ok)a += 10000 // -&gt; 2147493647.123 (ok)console.log(~~a) // -&gt; -2147483648 (huh?) 一个特别容易中招的地方是在处理Unix时间戳时(从1970年1月1日 00:00:00 UTC开始以秒测量)。一个快速获取的方法: 1epoch_int = ~~(+new Date() / 1000) // Date() 以毫秒计量，所以我们缩小它 然而，当处理2038年1月19日 03:14:07 UTC 之后的时间戳时（有时称为Y2038 limit）, 可怕的事情发生了： 12345678910// 2040年1月1日 00:00:00.123 UTC的时间戳epoch = +new Date('2040-01-01') / 1000 + 0.123 // -&gt; 2208988800.123// 回到未来!epoch_int = ~~epoch // -&gt; -2085978496console.log(new Date(epoch_int * 1000)) // -&gt; Wed Nov 25 1903 17:31:44 UTC// 这很搞笑，让我们来取得正确答案epoch_flr = Math.floor(epoch) // -&gt; 2208988800console.log(new Date(epoch_flr * 1000)) // -&gt; Sun Jan 01 2040 00:00:00 UTC 当原始输入的数据类型不确定时因为~~可以将任何非数字类型转换为0： 123console.log(~~[]) // -&gt; 0console.log(~~NaN) // -&gt; 0console.log(~~null) // -&gt; 0 一些程序员将其看作适当输入验证的替代品。然而，这将导致奇怪的逻辑问题，因此你不能辨别违法输入还是真正的0。因此这_并不_推荐。 当很多人认为~~X == Math.floor(X)时很多人由于很多原因错误的把”双按位非”等同于Math.floor()。如果你不能准确地使用它，最终你很有可能会滥用它。 另一些人很细心的注意正数使用Math.floor()而负数使用Math.ceil()，但这又强制你在处理它的时候需要停下来想一想你处理的数是什么值。这又违背了使用~~快捷无陷阱的目的。 结论尽量避免，并有节制的使用。 使用 谨慎使用。 在应用前检查值。 仔细记录被转化值的相关假设。 审查代码至少处理： 逻辑错误，不合法的输入作为合法的0传入其他代码模块 输入转换后范围错误 错误的舍入方向导致差一错误","tags":[]},{"title":"Node.js - 运行未被引用的模块","date":"2019-11-04T02:44:10.449Z","path":"2019/11/04/javascript/2016-01-17-nodejs-run-a-module-if-it-is-not-required/","text":"在Node里,你可以让你的程序根据其运行自require(&#39;./something.js&#39;)或者node something.js而做不同的处理。如果你想与你的一个独立的模块进行交互，这是非常有用的。 123456789if (!module.parent) &#123; // 通过 `node something.js` 启动 app.listen(8088, function() &#123; console.log('app listening on port 8088'); &#125;)&#125; else &#123; // 通过 `require('/.something.js')` 被引用 module.exports = app;&#125; 更多内容请看 modules的文档","tags":[]},{"title":"对数组洗牌","date":"2019-11-04T02:44:10.449Z","path":"2019/11/04/javascript/2016-01-21-shuffle-an-array/","text":"这段代码运用了Fisher-Yates Shuffling算法对数组进行洗牌。 123456789101112function shuffle(arr) &#123; var i, j, temp; for (i = arr.length - 1; i &gt; 0; i--) &#123; j = Math.floor(Math.random() * (i + 1)); temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; return arr; &#125;; 调用示例: 1234var a = [1, 2, 3, 4, 5, 6, 7, 8];var b = shuffle(a);console.log(b);// [2, 7, 8, 6, 5, 3, 1, 4]","tags":[]},{"title":"返回对象，使方法可以链式调用","date":"2019-11-04T02:44:10.449Z","path":"2019/11/04/javascript/2016-01-20-return-objects-to-enable-chaining-of-functions/","text":"在面向对象的Javascript中为对象建立一个方法时，返回当前对象可以让你在一条链上调用方法。 12345678910111213141516function Person(name) &#123; this.name = name; this.sayName = function() &#123; console.log(\"Hello my name is: \", this.name); return this; &#125;; this.changeName = function(name) &#123; this.name = name; return this; &#125;;&#125;var person = new Person(\"John\");person.sayName().changeName(\"Timmy\").sayName();","tags":[]},{"title":"安全的字符串拼接","date":"2019-11-04T02:44:10.449Z","path":"2019/11/04/javascript/2016-01-19-safe-string-concatenation/","text":"假如你需要拼接一些不确定类型的变量为字符串，你需要确保算术运算符在你拼接时不会起作用。使用concat： 12345var one = 1;var two = 2;var three = '3';var result = ''.concat(one, two, three); //\"123\" 这应该就是你所期望的拼接结果。如果不这样，拼接时加号可能会导致你意想不到的结果： 12345var one = 1;var two = 2;var three = '3';var result = one + two + three; //\"33\" instead of \"123\" 关于性能,与用join来拼接字符串相比 concat的效率是几乎一样的。 你可以在MDN了解更多关于concat方法的内容。","tags":[]},{"title":"更简单的使用indexOf实现contains功能","date":"2019-11-04T02:44:10.448Z","path":"2019/11/04/javascript/2016-01-15-even-simpler-way-of-using-indexof-as-a-contains-clause/","text":"JavaScript并未提供contains方法。检测子字符串是否存在于字符串或者变量是否存在于数组你可能会这样做： 1234567var someText = 'javascript rules';if (someText.indexOf('javascript') !== -1) &#123;&#125;// orif (someText.indexOf('javascript') &gt;= 0) &#123;&#125; 但是让我们看一下这些 Expressjs代码段。 examples/mvc/lib/boot.js 123for (var key in obj) &#123; // \"reserved\" exports if (~['name', 'prefix', 'engine', 'before'].indexOf(key)) continue; lib/utils.js 12345exports.normalizeType = function(type)&#123; return ~type.indexOf('/') ? acceptParams(type) : &#123; value: mime.lookup(type), params: &#123;&#125; &#125;;&#125;; examples/web-service/index.js 12// key is invalidif (!~apiKeys.indexOf(key)) return next(error(401, 'invalid api key')); 难点是 位操作符 ~, “按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值。” 它将-1转换为0,而0在javascript为false,所以: 12345var someText = 'text';!!~someText.indexOf('tex'); // someText contains \"tex\" - true!~someText.indexOf('tex'); // someText NOT contains \"tex\" - false~someText.indexOf('asd'); // someText doesn't contain \"asd\" - false~someText.indexOf('ext'); // someText contains \"ext\" - true String.prototype.includes()在ES6中提供了includes() 方法供我们判断一个字符串是否包含了另一个字符串: 1'something'.includes('thing'); // true 在ECMAScript 2016 (ES7)甚至可能将其应用于数组，像indexOf一样: 12!!~[1, 2, 3].indexOf(1); // true[1, 2, 3].includes(1); // true 不幸的是, 只有Chrome、Firefox、Safari 9及其更高版本和Edge支持了这功能。IE11及其更低版本并不支持最好在受控的环境中使用此功能","tags":[]},{"title":"模板字符串","date":"2019-11-04T02:44:10.448Z","path":"2019/11/04/javascript/2016-01-09-template-strings/","text":"ES6中，JS现在有了引号拼接字符串的替代品，模板字符串。 示例:普通字符串 1234var firstName = 'Jake';var lastName = 'Rawr';console.log('My name is ' + firstName + ' ' + lastName);// My name is Jake Rawr 模板字符串 1234var firstName = 'Jake';var lastName = 'Rawr';console.log(`My name is $&#123;firstName&#125; $&#123;lastName&#125;`);// My name is Jake Rawr 在模板字符串中，你可以不用\\n来生成多行字符串，在${}里做简单的逻辑运算（例如 2+3）甚至使用逻辑运算符。 123var val1 = 1, val2 = 2;console.log(`$&#123;val1&#125; is $&#123;val1 &lt; val2 ? 'less than': 'greater than'&#125; $&#123;val2&#125;`)// 1 is less than 2 你也可以使用函数修改末班字符串的输出内容；这被称为带标签的模板字符串，其中包含了带标签的模板字符串的示例. 或许你还想阅读更多内容来了解模板字符串。","tags":[]},{"title":"ES6中的伪强制参数","date":"2019-11-04T02:44:10.448Z","path":"2019/11/04/javascript/2016-01-12-pseudomandatory-parameters-in-es6-functions/","text":"在许多编程语言中，方法的参数是默认强制需要的，开发人员必须明确定义一个可选的参数。在Javascript 中每一个参数都是可选的，但是我们可以利用es6参数默认值特性的优点来达到强制要求这种目的，并且不污染函数体本身。 1234567891011const _err = function( message )&#123; throw new Error( message );&#125;const getSum = (a = _err('a is not defined'), b = _err('b is not defined')) =&gt; a + bgetSum( 10 ) // throws Error, b is not definedgetSum( undefined, 10 ) // throws Error, a is not defined _err 是一个即时抛出错误的方法。如果参数中的任何一个没有值，参数默认的值将会被使用， _err方法将被调用，并且会抛出一个错误。你可以从MDN看到更多关于默认参数特性的例子。","tags":[]},{"title":"变量提升","date":"2019-11-04T02:44:10.448Z","path":"2019/11/04/javascript/2016-01-11-hoisting/","text":"理解变量提升可以帮助你组织方法作用域。只要记住变量声明和方法声明都会被提升到顶部。变量的定义不会提升，即使你在同一行声明和定义一个变量。变量声明是让系统知道有这个变量存在而定义是给其赋值。 1234567891011121314151617181920212223242526272829303132function doTheThing() &#123; // ReferenceError: notDeclared is not defined console.log(notDeclared); // Outputs: undefined console.log(definedLater); var definedLater; definedLater = 'I am defined!' // Outputs: 'I am defined!' console.log(definedLater) // Outputs: undefined console.log(definedSimulateneously); var definedSimulateneously = 'I am defined!' // Outputs: 'I am defined!' console.log(definedSimulateneously) // Outputs: 'I did it!' doSomethingElse(); function doSomethingElse()&#123; console.log('I did it!'); &#125; // TypeError: undefined is not a function functionVar(); var functionVar = function()&#123; console.log('I did it!'); &#125;&#125; 为了让你的代码更易读，将所有的变量声明在函数的顶端，这样可以更清楚的知道变量来自哪个作用域。在使用变量之前声明变量。将方法定义在函数的底部。","tags":[]},{"title":"检查某对象是否有某属性","date":"2019-11-04T02:44:10.448Z","path":"2019/11/04/javascript/2016-01-10-check-if-a-property-is-in-a-object/","text":"当你需要检查某属性是否存在于一个对象，你可能会这样做： 123456var myObject = &#123; name: '@tips_js'&#125;;if (myObject.name) &#123; ... &#125; 这是可以的，但是你需要知道有两种原生方法可以解决此类问题。in 操作符 和 Object.hasOwnProperty，任何继承自Object的对象都可以使用这两种方法。 看一下较大的区别12345678910var myObject = &#123; name: '@tips_js'&#125;;myObject.hasOwnProperty('name'); // true'name' in myObject; // truemyObject.hasOwnProperty('valueOf'); // false, valueOf 继承自原型链'valueOf' in myObject; // true 两者检查属性的深度不同，换言之hasOwnProperty只在本身有此属性时返回true,而in操作符不区分属性来自于本身或继承自原型链。 这是另一个例子 12345678910var myFunc = function() &#123; this.name = '@tips_js';&#125;;myFunc.prototype.age = '10 days';var user = new myFunc();user.hasOwnProperty('name'); // trueuser.hasOwnProperty('age'); // false, 因为age来自于原型链 在线示例! 同样建议阅读关于检查对象是否包含属性时常见错误的讨论。","tags":[]},{"title":"箭头函数","date":"2019-11-04T02:44:10.448Z","path":"2019/11/04/javascript/2016-01-14-fat-arrow-functions/","text":"介绍一个ES6的新特性，箭头函数或许一个让你用更少行写更多代码的方便工具。它的名字(fat arrow functions)来自于它的语法=&gt;是一个比瘦箭头-&gt;要’胖的箭头’（译者注：但是国内貌似不分胖瘦就叫箭头函数）。Some programmers might already know this type of functions from different languages such as Haskell as ‘lambda expressions’ respectively ‘anonymous functions’. It is called anonymous, as these arrow functions do not have a descriptive function name.（译者注：一些其他语言中的箭头函数，避免不准确就不翻译了 欢迎PR） 有什么益处呢? 语法: 更少的代码行; 不再需要一遍一遍的打function了 语义: 从上下文中捕获this关键字 简单的语法示例观察一下这两个功能完全相同的代码片段。你将很快明白箭头函数做了什么。 12345678910111213141516171819// 箭头函数的一般语法param =&gt; expression// 也可以用用小括号// 多参数时小括号是必须的(param1 [, param2]) =&gt; expression// 使用functionsvar arr = [5,3,2,9,1];var arrFunc = arr.map(function(x) &#123; return x * x;&#125;);console.log(arr)// 使用箭头函数var arr = [5,3,2,9,1];var arrFunc = arr.map((x) =&gt; x*x);console.log(arr) 正如你所看到的，箭头函数在这种情况下省去了写小括号，function以及return的时间。我建议你总是使用小括号，因为对于像(x,y) =&gt; x+y这样多参数函数，小括号总是需要的。这仅是以防在不同使用场景下忘记小括号的一种方法。但是上面的代码和x =&gt; x*x是一样的。至此仅是语法上的提升，减少了代码行数并提高了可读性。 Lexically binding this这是另一个使用箭头函数的好原因。这是一个关于this上下文的问题。使用箭头函数，你不需要再担心.bind(this)也不用再设置that = this了，因为箭头函数继承了外围作用域的this值。看一下下面的示例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 全局定义 this.ithis.i = 100;var counterA = new CounterA();var counterB = new CounterB();var counterC = new CounterC();var counterD = new CounterD();// 不好的例子function CounterA() &#123; // CounterA的`this`实例 (!!调用时忽略了此实例) this.i = 0; setInterval(function () &#123; // `this` 指向全局(global)对象,而不是CounterA的`this` // 所以从100开始计数,而不是0 (本地的this.i) this.i++; document.getElementById(\"counterA\").innerHTML = this.i; &#125;, 500);&#125;// 手动绑定 that = thisfunction CounterB() &#123; this.i = 0; var that = this; setInterval(function() &#123; that.i++; document.getElementById(\"counterB\").innerHTML = that.i; &#125;, 500);&#125;// 使用 .bind(this)function CounterC() &#123; this.i = 0; setInterval(function() &#123; this.i++; document.getElementById(\"counterC\").innerHTML = this.i; &#125;.bind(this), 500);&#125;// 箭头函数function CounterD() &#123; this.i = 0; setInterval(() =&gt; &#123; this.i++; document.getElementById(\"counterD\").innerHTML = this.i; &#125;, 500);&#125; 更多有关箭头函数的内容可以查看MDN。更多语法选项请看这里.","tags":[]},{"title":"测量javascript代码块性能的小知识","date":"2019-11-04T02:44:10.448Z","path":"2019/11/04/javascript/2016-01-13-tip-to-measure-performance-of-a-javascript-block/","text":"快速的测量javascript的性能，我们可以使用console的方法，例如console.time(label) 和 console.timeEnd(label) 123456789console.time(\"Array initialize\");var arr = new Array(100), len = arr.length, i;for (i = 0; i &lt; len; i++) &#123; arr[i] = new Object();&#125;;console.timeEnd(\"Array initialize\"); // Outputs: Array initialize: 0.711ms 更多内容:Console object,Javascript benchmarking Demo: jsfiddle - codepen (在浏览器控制台输出) 注意：由于Mozilla不建议将其使用在线上项目中，建议仅在开发中使用。","tags":[]},{"title":"排列含音节字母的字符串","date":"2019-11-04T02:44:10.447Z","path":"2019/11/04/javascript/2016-01-04-sorting-strings-with-accented-characters/","text":"Javascript有一个原生方法sort可以排列数组。一次简单的array.sort()将每一个数组元素视为字符串并按照字母表排列。你也可以提供自定义排列方法。 12['Shanghai', 'New York', 'Mumbai', 'Buenos Aires'].sort();// [\"Buenos Aires\", \"Mumbai\", \"New York\", \"Shanghai\"] 但是当你试图整理一个如[&#39;é&#39;, &#39;a&#39;, &#39;ú&#39;, &#39;c&#39;]这样的非ASCII元素的数组时，你可能会得到一个奇怪的结果[&#39;c&#39;, &#39;e&#39;, &#39;á&#39;, &#39;ú&#39;]。这是因为排序方法只在英文下有用。 看一下下一个例子: 1234567// 西班牙语['único','árbol', 'cosas', 'fútbol'].sort();// [\"cosas\", \"fútbol\", \"árbol\", \"único\"] // bad order// 德语['Woche', 'wöchentlich', 'wäre', 'Wann'].sort();// [\"Wann\", \"Woche\", \"wäre\", \"wöchentlich\"] // bad order 幸运的是，有两种方法可以解决这个问题，由ECMAScript国际化API提供的localeCompare和Intl.Collator。 两个方法都有自定义配置参数可以使其更好用。 使用localeCompare()123456789['único','árbol', 'cosas', 'fútbol'].sort(function (a, b) &#123; return a.localeCompare(b);&#125;);// [\"árbol\", \"cosas\", \"fútbol\", \"único\"]['Woche', 'wöchentlich', 'wäre', 'Wann'].sort(function (a, b) &#123; return a.localeCompare(b);&#125;);// [\"Wann\", \"wäre\", \"Woche\", \"wöchentlich\"] 使用Intl.Collator()12345['único','árbol', 'cosas', 'fútbol'].sort(Intl.Collator().compare);// [\"árbol\", \"cosas\", \"fútbol\", \"único\"]['Woche', 'wöchentlich', 'wäre', 'Wann'].sort(Intl.Collator().compare);// [\"Wann\", \"wäre\", \"Woche\", \"wöchentlich\"] 两个方法都可以自定义区域位置。 根据Firefox，当比较大数量的字符串时，使用Intl.Collator更快。 所以当你处理一个由非英语组成的字符串数组时，记得使用此方法来避免排序出现意外。","tags":[]},{"title":"undefined与null的区别","date":"2019-11-04T02:44:10.447Z","path":"2019/11/04/javascript/2016-01-05-differences-between-undefined-and-null/","text":"undefined表示一个变量没有被声明，或者被声明了但没有被赋值 null是一个表示“没有值”的值 Javascript将未赋值的变量默认值设为undefined Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。 undefined不是一个有效的JSON，而null是 undefined的类型(typeof)是undefined null的类型(typeof)是object. 为什么? 它们都是基本类型 他们都是falsy(Boolean(undefined) // false, Boolean(null) // false) 你可以这样判断一个变量是否是undefined 1typeof variable === \"undefined\" 你可以这样判断一个变量是否是null 1variable === null 双等号比较时它们相等，但三等号比较时不相等 123null == undefined // truenull === undefined // false","tags":[]},{"title":"优化嵌套的条件语句","date":"2019-11-04T02:44:10.447Z","path":"2019/11/04/javascript/2016-01-03-improve-nested-conditionals/","text":"我们怎样来提高和优化javascript里嵌套的if语句呢？ 12345678910111213if (color) &#123; if (color === 'black') &#123; printBlackBackground(); &#125; else if (color === 'red') &#123; printRedBackground(); &#125; else if (color === 'blue') &#123; printBlueBackground(); &#125; else if (color === 'green') &#123; printGreenBackground(); &#125; else &#123; printYellowBackground(); &#125;&#125; 一种方法来提高嵌套的if语句是用switch语句。虽然它不那么啰嗦而且排列整齐，但是并不建议使用它，因为这对于调试错误很困难。这告诉你为什么. 12345678910111213141516switch(color) &#123; case 'black': printBlackBackground(); break; case 'red': printRedBackground(); break; case 'blue': printBlueBackground(); break; case 'green': printGreenBackground(); break; default: printYellowBackground();&#125; 如果可以重构的话，我们可以试着简化函数。比如不需要为每个颜色写一个函数，而是将颜色作为函数的参数。 12345function printBackground(color) &#123; if (!color || typeof color !== 'string') &#123; return; // Invalid color, return immediately &#125;&#125; 但是如果不能重构的话，我们必须避免过多的条件检查，避免过多使用switch。我们必须考虑最有效率的方法，使用object。 1234567891011121314151617switch(true) &#123; case (typeof color === 'string' &amp;&amp; color === 'black'): printBlackBackground(); break; case (typeof color === 'string' &amp;&amp; color === 'red'): printRedBackground(); break; case (typeof color === 'string' &amp;&amp; color === 'blue'): printBlueBackground(); break; case (typeof color === 'string' &amp;&amp; color === 'green'): printGreenBackground(); break; case (typeof color === 'string' &amp;&amp; color === 'yellow'): printYellowBackground(); break;&#125; 但是我们应该时刻注意避免太多判断在一个条件里，尽量少的使用switch，考虑最有效率的方法：借助object。 123456789101112var colorObj = &#123; 'black': printBlackBackground, 'red': printRedBackground, 'blue': printBlueBackground, 'green': printGreenBackground, 'yellow': printYellowBackground&#125;;if (color in colorObj) &#123; colorObj[color]();&#125; 这里有更多相关的内容.","tags":[]},{"title":"使用\"use strict\" 变得懒惰","date":"2019-11-04T02:44:10.447Z","path":"2019/11/04/javascript/2016-01-07-use-strict-and-get-lazy/","text":"（译者注：此片翻译较渣，欢迎指正，建议大家阅读原文或直接阅读MDN对严格模式的中文介绍 并欢迎PR） JavaScript的严格模式使开发者更容易写出“安全”的代码。 通常情况下，JavaScript允许程序员相当粗心，比如你可以引用一个从未用”var”声明的变量。或许对于一个刚入门的开发者来说这看起来很方便，但这也是变量拼写错误或者从作用域外引用变量时引发的一系列错误的原因。 程序员喜欢电脑帮我们做一些无聊的工作，喜欢它自动的检查我们工作上的错误。这就是”use strict”帮我们做的，它把我们的错误转变为了JavaScript错误。 我们把这个指令放在js文件顶端来使用它: 123// 全脚本严格模式\"use strict\";var v = \"Hi! I'm a strict mode script!\"; 或者放在一个方法内： 123456789function f()&#123; // 方法级严格模式 'use strict'; function nested() &#123; return \"And so am I!\"; &#125; return \"Hi! I'm a strict mode function! \" + nested();&#125;function f2() &#123; return \"I'm not strict.\"; &#125; 通过在JavaScript文件或方法内引入此指令，使JavaScript引擎运行在严格模式下，这直接禁止了许多大项目中不受欢迎的操作。另外，严格模式也改变了以下行为： 只有被”var”声明过的变量才可以引用 试图写只读变量时将会报错 只能通过”new”关键字调用构造方法 “this”不再隐式的指向全局变量 对eval()有更严格的限制 防止你使用预保留关键字命名变量 严格模式对于新项目来说是很棒的，但对于一些并没有使用它的老项目来说，引入它也是很有挑战性的。如果你把所有js文件都连接到一个大文件中的话，可能导致所有文件都运行在严格模式下，这可能也会有一些问题。 它不是一个声明，而是一个表达式，被低版本的JavaScript忽略。严格模式的支持情况： Internet Explorer 10+ Firefox 4+ Chrome 13+ Safari 5.1+ Opera 12+ MDN对严格模式的全面介绍","tags":[]},{"title":"向数组中插入元素","date":"2019-11-04T02:44:10.447Z","path":"2019/11/04/javascript/2015-12-29-insert-item-inside-an-array/","text":"向一个数组中插入元素向一个数组中插入元素是平时很常见的一件事情。你可以使用push在数组尾部插入元素,可以用unshift在数组头部插入元素,也可以用splice在数组中间插入元素。 但是这些已知的方法，并不意味着没有更加高效的方法。让我们接着往下看…… 向数组结尾添加元素向数组结尾添加元素用push()很简单，但下面有一个更高效的方法 123456var arr = [1,2,3,4,5];var arr2 = [];arr.push(6);arr[arr.length] = 6;arr2 = arr.concat([6]); 两种方法都是修改原始数组。不信？看看jsperf 手机上的效率Android (v4.2.2) arr.push(6); and arr[arr.length] = 6; 性能相同 // 3 319 694 ops/sec arr2 = arr.concat([6]); 比其他两个方法慢50.61% Chrome Mobile (v33.0.0) arr[arr.length] = 6; // 6 125 975 ops/sec arr.push(6); 慢66.74% arr2 = arr.concat([6]); 慢87.63% Safari Mobile (v9) arr[arr.length] = 6; // 7 452 898 ops/sec arr.push(6); 慢40.19% arr2 = arr.concat([6]); 慢49.78% 12345最快的为1. arr[arr.length] = 6; // 平均 5 632 856 ops/sec2. arr.push(6); // 慢35.64%3. arr2 = arr.concat([6]); // 慢62.67% 桌面上的效率Chrome (v48.0.2564) arr[arr.length] = 6; // 21 602 722 ops/sec arr.push(6); 慢61.94% arr2 = arr.concat([6]); 慢87.45% Firefox (v44) arr.push(6); // 56 032 805 ops/sec arr[arr.length] = 6; 慢0.52% arr2 = arr.concat([6]); 慢87.36% IE (v11) arr[arr.length] = 6; // 67 197 046 ops/sec arr.push(6); 慢39.61% arr2 = arr.concat([6]); 慢93.41% Opera (v35.0.2066.68) arr[arr.length] = 6; // 30 775 071 ops/sec arr.push(6); 慢71.60% arr2 = arr.concat([6]); 慢83.70% Safari (v9.0.3) arr.push(6); // 42 670 978 ops/sec arr[arr.length] = 6; 慢0.80% arr2 = arr.concat([6]); 慢76.07% 12345最快的为1. arr[arr.length] = 6; // 平均42 345 449 ops/sec2. arr.push(6); // 慢34.66%3. arr2 = arr.concat([6]); // 慢85.79% 向数组的头部添加元素现在我们试着向数组的头部添加元素： 12345var arr = [1,2,3,4,5];arr.unshift(0);[0].concat(arr); 这里有一些小区别，unshift操作的是原始数组，concat返回一个新数组，参考jsperf 手机上的效率 :Android (v4.2.2) [0].concat(arr); // 1 808 717 ops/sec arr.unshift(0); 慢97.85% Chrome Mobile (v33.0.0) [0].concat(arr); // 1 269 498 ops/sec arr.unshift(0); 慢99.86% Safari Mobile (v9) arr.unshift(0); // 3 250 184 ops/sec [0].concat(arr); 慢33.67% 1234最快的为1. [0].concat(arr); // 平均4 972 622 ops/sec2. arr.unshift(0); // 慢64.70% 桌面上的效率Chrome (v48.0.2564) [0].concat(arr); // 2 656 685 ops/sec arr.unshift(0); 慢96.77% Firefox (v44) [0].concat(arr); // 8 039 759 ops/sec arr.unshift(0); 慢99.72% IE (v11) [0].concat(arr); // 3 604 226 ops/sec arr.unshift(0); 慢98.31% Opera (v35.0.2066.68) [0].concat(arr); // 4 102 128 ops/sec arr.unshift(0); 慢97.44% Safari (v9.0.3) arr.unshift(0); // 12 356 477 ops/sec [0].concat(arr); 慢15.17% 1234最快的为1. [0].concat(arr); // 平均6 032 573 ops/sec2. arr.unshift(0); // 慢78.65% 向数组中间添加元素使用splice可以简单的向数组中间添加元素，这也是最高效的方法。 12var items = ['one', 'two', 'three', 'four'];items.splice(items.length / 2, 0, 'hello'); 我在许多浏览器和系统中进行了测试，结果都是相似的。希望这条小知识可以帮到你，也欢迎大家自行测试。","tags":[]},{"title":"将Node List转换为数组(Array)","date":"2019-11-04T02:44:10.447Z","path":"2019/11/04/javascript/2016-01-08-converting-a-node-list-to-an-array/","text":"querySelectorAll方法返回一个类数组对象称为node list。这些数据结构被称为“类数组”，因为他们看似数组却没有类似map、foreach这样的数组方法。这是一个快速、安全、可重用的方法将node list转换为DOM元素的数组： 123456789101112const nodelist = document.querySelectorAll('div');const nodelistToArray = Array.apply(null, nodelist);//之后 ..nodelistToArray.forEach(...);nodelistToArray.map(...);nodelistToArray.slice(...);//等... apply方法可以在指定this时以数组形式向方法传递参数。MDN规定apply可以接受类数组对象,恰巧就是querySelectorAll方法所返回的内容。如果我们不需要指定方法内this的值时传null或0即可。返回的结果即包含所有数组方法的DOM元素数组。 另外你可以使用Array.prototype.slice结合Function.prototype.call或Function.prototype.apply， 将类数组对象当做this传入： 12345678910const nodelist = document.querySelectorAll('div');const nodelistToArray = Array.prototype.slice.call(nodelist); // or equivalently Array.prototype.slice.apply(nodelist);//之后 ..nodelistToArray.forEach(...);nodelistToArray.map(...);nodelistToArray.slice(...);//等... 如果你正在用ES2015你可以使用展开运算符 ... 12345678910const nodelist = [...document.querySelectorAll('div')]; // 返回一个真正的数组//之后 ..nodelist.forEach(...);nodelist.map(...);nodelist.slice(...);//等...","tags":[]},{"title":"可以接受单参数与数组的方法","date":"2019-11-04T02:44:10.447Z","path":"2019/11/04/javascript/2016-01-06-writing-a-single-method-for-arrays-and-a-single-element/","text":"写一个方法可以接受单个参数也可以接受一个数组，而不是分开写两个方法。这和jQuery的一些方法的工作原理很像(css 可以修改任何匹配到的选择器). 你只要把任何东西连接到一个数组. Array.concat可以接受一个数组也可以接受单个参数。 123456function printUpperCase(words) &#123; var elements = [].concat(words || []); for (var i = 0; i &lt; elements.length; i++) &#123; console.log(elements[i].toUpperCase()); &#125;&#125; printUpperCase现在可以接受单个单词或多个单词的数组作为它的参数。同时也可以避免在不传递参数时抛出的TypeError错误的隐患。 123456printUpperCase(\"cactus\");// =&gt; CACTUSprintUpperCase([\"cactus\", \"bear\", \"potato\"]);// =&gt; CACTUS// BEAR// POTATO","tags":[]},{"title":"AngularJs - $digest vs $apply","date":"2019-11-04T02:44:10.446Z","path":"2019/11/04/angular/2016-01-01-angularjs-digest-vs-apply/","text":"AngularJs最令人欣赏的特性之一就是双向数据绑定。AngularJs通过循环($digest)检查model和view的变化实现此功能。想要理解框架底层的运行机制你需要理解这个概念。 当一个事件被触发时，Angular触发每个watcher. 这是我们已知的$digest循环。有时你需要强制手动运行一个新的循环，而且因为这是最影响性能的一方面，你必须选择一个正确的选项。 $apply这个核心方法可以让你显式启动digest循环。这意味着所有的watcher将会被检测；整个应用启动$digest loop。在内部在会执行一个可选的方法之后，会调用$rootScope.$digest();. $digest这种情况下$digest方法在当前作用域和它的子作用域启动$digest循环。你需要注意他的父作用域将不会被检测也不会被影响。 推荐 仅当浏览器DOM事件在AngularJS之外被触发时使用$apply或$digest。 给$apply传递方法，它将包含错误处理机制而且允许整合在digest循环里的变化。 123$scope.$apply(() =&gt; &#123; $scope.tip = 'Javascript Tip';&#125;); 如果你只需要更新当前的作用域或者它的子作用域的话，使用$digest，而且要防止在整个应用里运行新的digest循环。这在性能上的好处是显而易见的。 $apply()对机器来说是一个困难的处理过程，在绑定过多的时候可能会引发性能问题。 如果你正使用&gt;AngularJS 1.2.X版本，使用$evalAsync, 这个方法将在当前循环或下一个循环执行表达式，这能提高你的应用的性能。","tags":[]},{"title":"2017年04月12日21-30-30","date":"2019-11-04T02:44:10.444Z","path":"2019/11/04/2017年04月12日21-30-30/","text":"title: ‘2017年04月12日21:30:30’date: 2017-04-12 21:30:34tags: Hexo经过不懈的努力，终于把Mac版的Hexo静态博客搞完了。下面应该开始切换主题了。希望一切成功。加油！！！！！！","tags":[]},{"title":"HTML5 新特性","date":"2017-07-30T04:09:09.000Z","path":"2017/07/30/20170730/","text":"今天来谈谈前端面试中基本上每次一面的时候都会被问到的一个问题，那就是html5的新特性。这个是学习前端必须掌握的基础知识。 新增的元素html5新增了一些语义化更好的标签元素。 结构元素 article元素，表示页面中的一块与上下文不相关的独立内容，比如博客中的一篇文章。aside元素，表示article内容之外的内容，辅助信息。header元素，表示页面中一个内容区块或整个页面的页眉。hgroup元素，用于对页面中一个区块或整个页面的标题进行组合。footer元素，表示页面中一个内容区块或整个页面的页脚。figure元素，表示媒介内容的分组，以及它们的标题。section元素，表示页面中一个内容区块，比如章节。nav元素，表示页面中的导航链接。 其他元素 video元素，用来定义视频。audio元素，用来定义音频。canvas元素，用来展示图形，该元素本身没有行为，仅提供一块画布。embed元素，用来插入各种多媒体，格式可以是Midi、Wav、AIFF、AU、MP3等。mark元素，用来展示高亮的文字。progress元素，用来展示任何类型的任务的进度。meter元素，表示度量衡，定义预定义范围内的度量。time元素，用来展示日期或者时间。command元素，表示命令按钮。details元素，用来展示用户要求得到并且可以得到的细节信息。summary元素，用来为details元素定义可见的标题。datalist元素，用来展示可选的数据列表，与input元素配合使用，可以制作出输入值的下拉列表。datagrid元素，也用来展示可选的数据列表，以树形列表的形式来显示。keygen元素，表示生成密匙。output元素，表示不同类型的输出。source元素，为媒介元素定义媒介资源。menu元素，表示菜单列表。ruby元素，表示ruby注释， rt元素表示字符的解释或发音。 rp元素在ruby注释中使用，以定义不支持ruby元素的浏览器所显示的内容。wbr元素，表示软换行。与br元素的区别是：br元素表示此处必须换行，而wbr元素的意思是浏览器窗口或父级元素的宽度够宽时。不进行换行，而当宽度不够时，主动在此处进行换行。bdi元素，定义文本的文本方向，使其脱离其周围文本的方向设置。dialog元素，表示对话框或窗口。 废除的元素html5中废除了一些纯表现的元素，只有部分浏览器支持的元素还有一些会对可用性产生负面影响的元素。 纯表现元素纯表现的元素就是那些可以用css替代的元素。basefont、big、center、font、s、strike、tt、u这些元素，他们的功能都是纯粹为页面展示服务的，html5提倡把页面展示性功能放在css样式表中统一处理，所以将这些元素废除，用css样式进行替代。 对可用性产生负面影响的元素 对于frameset元素、frame元素与noframes元素，由于frame框架对网页可用性存在负面影响，在html5中已不支持frame框架，只支持iframe框架，html5中同时将frameset、frame和noframes这三个元素废除。 只有部分浏览器支持的元素 对于applet、bgsound、blink、marquee等元素，由于只有部分浏览器支持，特别是bgsound元素以及marquee元素，只被IE支持，所以在html5中被废除。其中applet元素可由embed元素或object元素替代，bgsound元素可由audio元素替代，marquee可以由javascript编程的方式替代。 新增的APICanvas API上文提到的canvas元素可以为页面提供一块画布来展示图形。结合Canvas API，就可以在这块画布上动态生成和展示各种图形、图表、图像以及动画了。Canvas本质上是位图画布，不可缩放，绘制出来的对象不属于页面DOM结构或者任何命名空间。不需要将每个图元当做对象存储，执行性能非常好。 利用Canvas API进行绘图，首先要获取canvas元素的上下文，然后用该上下文中封装的各种绘图功能进行绘图。 123456789101112&lt;canvas id=\"canvas\"&gt;替代内容&lt;/canvas&gt;&lt;script&gt; var canvas = document.getElementById('canvas'); var context =canvas.getContext(\"2d\"); // 获取上下文 //设置纯色 context.fillStyle = \"red\"; context.strokeStyle = \"blue\"; // 实践表明在不设置fillStyle下的默认fillStyle为black context.fillRect(0, 0, 100, 100); // 实践表明在不设置strokeStyle下的默认strokeStyle为black context.strokeRect(120, 0, 100, 100);&lt;/script&gt; SVGSVG是html5的另一项图形功能，它是一种标准的矢量图形，是一种文件格式，有自己的API。html5引入了内联SVG，使得SVG元素可以直接出现在html标记中。 1&lt;svg height=100 width=100&gt;&lt;circle cx=50 cy=50 r=50 /&gt;&lt;/svg&gt; 音频和视频audio和video元素的出现让html5的媒体应用多了新选择，开发人员不必使用插件就能播放音频和视频。对于这两个元素，html5规范提供了通用、完整、可脚本化控制的API。html5规范出来之前，在页面中播放视频的典型方式是使用Flash、QuickTime或者Windows Media插件往html中嵌入音频视频，相对这种方式，使用html5的媒体标签有两大好处。 作为浏览器原生支持的功能，新的audio和video元素无需安装。媒体元素想Web页面提供了通用、集成和可脚本化控制的API。 123456&lt;video src=\"video.webm\" controls&gt; &lt;object data=\"videoplayer.swf\" type=\"application/x-shockwave-flash\"&gt; &lt;param name=\"movie\" value=\"video.swf\" /&gt; &lt;/object&gt; Your browser does not support HTML5 video.&lt;/video&gt; 浏览器支持性检测浏览器检测是否支持audio元素或者video元素最简单的方式是用脚本动态创建它，然后检测特定函数是否存在 12var hasVideo = !!(document.createElement('video').canPlayType);Geolocation API html5的Geolocation API（地理定位API），可以请求用户共享他们的位置。使用方法非常简单，如果用户同意，浏览器就会返回位置信息，该位置信息是通过支持html5地理定位功能的底层设备（如笔记本电脑或手机）提供给浏览器的。位置信息由纬度、经度坐标和一些其他元数据组成。 位置信息从何而来 Geolocation API不指定设备使用哪种底层技术来定位应用程序的用户。相反，它只是用于检索位置信息的API，而且通过该API检索到的数据只具有某种程度的准确性，并不能保证设备返回的位置是精确的。设备可以使用下列数据源： IP地址三维坐标GPS从RFID、WiFi和蓝牙到WiFi的MAC地址GSM或CDMA手机的ID用户自定义数据使用方法 12345678910111213141516// 一次更新navigator.geolocation.getCurrentPosition(updateLocation, handleLocationEror);function updateLocation(position) &#123; var latitude = position.coords.latitude; // 纬度 var longitude = position.coords.longitude; // 经度 var accuracy = position.coords.accuracy; // 准确度 var timestamp = position.coords.timestamp; // 时间戳&#125;// 错误处理函数function handleLocationEror(error) &#123; ....&#125;// 重复更新navigator.geolocation.watchPosition(updateLocation, handleLocationEror);// 不再接受位置更新navigator.geolocation.clearWatch(watchId); Communication API跨文档消息传递出于安全方面的考虑，运行在同一浏览器中的框架、标签页、窗口间的通信一直都受到了严格的限制。然而，现实中存在一些合理的让不同站点的内容能在浏览器内进行交互的需求。这种情形下，如果浏览器内部能提供直接的通信机制，就能更好地组织这些应用。html5中引入了一种新功能，跨文档消息通信，可以确保iframe、标签页、窗口间安全地进行跨源通信。postMessage API为发送消息的标准方式，发送消息非常简单： 1window.postMessage('Hello, world', 'http://www.example.com/'); 接收消息时，仅需在页面中增加一个事件处理函数。当某个消息到达时，通过检查消息的来源来决定是否对这条消息进行处理。 123456789101112window.addEventListener(\"message\", messageHandler, true);function messageHandler(e) &#123; switch(e.origin) &#123; case \"friend.example.com\": // 处理消息 processMessage(e.data); break; default: // 消息来源无法识别 // 消息被忽略 &#125;&#125; 消息事件是一个拥有data(数据)和origin(源)属性的DOM事件。data属性是发送方传递的实际消息，而origin属性是发送来源。 XMLHttpRequest Level2XMLHttpRequest API使得Ajax技术成为可能，作为XMLHttpRequest的改进版，XMLHttpRequest Level2在功能上有了很大的改进。主要两个方面： 跨源XMLHttpRequest进度事件跨源XMLHttpRequest 过去，XMLHttpRequest仅限于同源通信，XMLHttpRequest Level2通过CORS实现了跨源XMLHttpRequest。跨源HTTP请求包含一个Origin头部，它为服务器提供HTTP请求的源信息。 WebSockets APIWebSockets是html5中最强大的通信功能，它定义了一个全双工通信信道，仅通过Web上的一个Socket即可进行通信。 WebSockets握手为了建立WebSockets通信，客户端和服务器在初始握手时，将HTTP协议升级到WebSocket协议。一旦连接建立成功，就可以在全双工模式下在客户端和服务器之间来回传递WebSocket消息。 WebSockets接口除了对WebSockets协议定义外，该规范还同时定义了用于JavaScript应用程序的WebSocket接口。WebSockets接口的使用很简单。要连接远程主机，只需要新建一个WebSocket实例，提供希望连接的对端URL。 Forms API新表单元素tel元素，表示电话号码。email元素，表示电子邮件地址文本框。url元素，表示网页的url。search元素，用于搜索引擎，比如在站点顶部显示的搜索框。range元素，特定值范围内的数值选择器，典型的显示方式是滑动条。number元素，只包含数值的字段。 未来的表单元素color元素，颜色选择器，基于调色盘或者取色板进行选择。datetime元素，显示完整的日期和时间，包括时区。datetime-local，显示日期和时间。time元素，不含时区的时间选择器和指示器。date元素，日期选择器。week元素，某年中的周选择器。month元素，某年中的月选择器。新的表单特性和函数 placeholder当用户还没输入值的时候，输入型控件可以通过placeholder特性向用户显示描述性说明或者提示信息。 1&lt;input name=\"name\" placeholder=\"First and last name\"&gt; autocomplete 浏览器通过autocomplete特性能够知晓是否应该保存输入值以备将来使用。 autofocus 通过autofocus特性可以指定某个表单元素获得输入焦点，每个页面上只允许出现一个autofocus特性，如果设置了多个，则相当于未指定此行为。 spellcheck 可对带有文本内容的输入控件和textarea空间控制spellcheck属性。设置完后，会询问浏览器是否应该给出拼写检查结果反馈。spellcheck属性需要赋值。 list特性和datalist元素通过组合使用list特性和datalist元素，开发人员能够为某个输入型控件构造一张选值列表。 12345&lt;datalist id=\"contactList\"&gt; &lt;option value=\"a@qq.com\"&gt;&lt;/option&gt; &lt;option value=\"b@qq.com\"&gt;&lt;/option&gt;&lt;/datalist&gt;&lt;input type=\"email\" id=\"contatcs\" list=\"contactList\"&gt; min和max 通过设置min和max特性，可以将range输入框的数值输入范围限定在最低值和最高值之间。可以只设置一个，也可以两个都设置，也可以都不设置。 step对于输入型控件，设置其step特性能够指定输入值递增或者递减的粒度。 required一旦为某输入型控件设置了required特性，那么此项必填，否则无法提交表单。 拖放APIdraggable属性 如果网页元素的draggable元素为true，这个元素就是可以拖动的。 1&lt;div draggable=\"true\"&gt;Draggable Div&lt;/div&gt; 拖放事件拖动过程会触发很多事件，主要有下面这些： dragstart：网页元素开始拖动时触发。drag：被拖动的元素在拖动过程中持续触发。dragenter：被拖动的元素进入目标元素时触发，应在目标元素监听该事件。dragleave：被拖动的元素离开目标元素时触发，应在目标元素监听该事件。dragover：被拖动元素停留在目标元素之中时持续触发，应在目标元素监听该事件。drap：被拖动元素或从文件系统选中的文件，拖放落下时触发。dragend：网页元素拖动结束时触发。 123draggableElement.addEventListener('dragstart', function(e) &#123; console.log('拖动开始！');&#125;); dataTransfer对象拖动过程中，回调函数接受的事件参数，有一个dataTransfer属性，指向一个对象，包含与拖动相关的各种信息。 123draggableElement.addEventListener('dragstart', function(event) &#123; event.dataTransfer.setData('text', 'Hello World!');&#125;); dataTransfer对象的属性有：dropEffect：拖放的操作类型，决定了浏览器如何显示鼠标形状，可能的值为copy、move、link和none。effectAllowed：指定所允许的操作，可能的值为copy、move、link、copyLink、copyMove、linkMove、all、none和uninitialized（默认值，等同于all，即允许一切操作）。files：包含一个FileList对象，表示拖放所涉及的文件，主要用于处理从文件系统拖入浏览器的文件。types：储存在DataTransfer对象的数据的类型。 dataTransfer对象的方法有：setData(format, data)：在dataTransfer对象上储存数据。第一个参数format用来指定储存的数据类型，比如text、url、text/html等。getData(format)：从dataTransfer对象取出数据。clearData(format)：清除dataTransfer对象所储存的数据。如果指定了format参数，则只清除该格式的数据，否则清除所有数据。setDragImage(imgElement, x, y)：指定拖动过程中显示的图像。默认情况下，许多浏览器显示一个被拖动元素的半透明版本。参数imgElement必须是一个图像元素，而不是指向图像的路径，参数x和y表示图像相对于鼠标的位置。 Web Workers APIJavascript是单线程的。因此，持续时间较长的计算，回阻塞UI线程，进而导致无法在文本框中填入文本，单击按钮等，并且在大多数浏览器中，除非控制权返回，否则无法打开新的标签页。该问题的解决方案是Web Workers，可以让Web应用程序具备后台处理能力，对多线程的支持性非常好。 但是在Web Workers中执行的脚本不能访问该页面的window对象，也就是Web Workers不能直接访问Web页面和DOM API。虽然Web Workers不会导致浏览器UI停止响应，但是仍然会消耗CPU周期，导致系统反应速度变慢。 Web Storage APIWeb Storage是html5引入的一个非常重要的功能，可以在客户端本地存储数据，类似html4的cookie，但可实现功能要比cookie强大的多。 sessionStorage sessionStorage将数据保存在session中，浏览器关闭数据就消失。 localStorage localStorage则一直将数据保存在客户端本地，除非手动删除，否则一直保存。不管是sessionStorage，还是localStorage，可使用的API相同，常用的有如下几个（以localStorage为例）： 保存数据：localStorage.setItem(key,value);读取数据：localStorage.getItem(key);删除单个数据：localStorage.removeItem(key);删除所有数据：localStorage.clear();得到某个索引的key：localStorage.key(index);","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"文本滚动","date":"2017-07-25T05:57:30.000Z","path":"2017/07/25/文本滚动-20170725/","text":"文本滚动包括从上到下／从左到右／等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;向上下左右不间断无缝滚动效果(兼容火狐和IE)&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"colee\" style=\"overflow:hidden;height:253px;width:410px;\"&gt; &lt;div id=\"colee1\"&gt; &lt;p&gt;此处放文字。。。。。。。。。1&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。2&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。3&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。4&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。5&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。6&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。7&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。8&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。9&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。0&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。11&lt;/p&gt; &lt;p&gt;此处放文字。。。。。。。。。12&lt;/p&gt; &lt;/div&gt; &lt;div id=\"colee2\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var speed = 30; var colee2 = document.getElementById(\"colee2\"); var colee1 = document.getElementById(\"colee1\"); var colee = document.getElementById(\"colee\"); colee2.innerHTML = colee1.innerHTML; //克隆colee1为colee2 function Marquee1() &#123; //当滚动至colee1与colee2交界时 if (colee2.offsetTop - colee.scrollTop &lt;= 0) &#123; colee.scrollTop -= colee1.offsetHeight; //colee跳到最顶端 &#125; else &#123; colee.scrollTop++ &#125; &#125; var MyMar1 = setInterval(Marquee1, speed) //设置定时器 //鼠标移上时清除定时器达到滚动停止的目的 colee.onmouseover = function() &#123; clearInterval(MyMar1) &#125; //鼠标移开时重设定时器 colee.onmouseout = function() &#123; MyMar1 = setInterval(Marquee1, speed) &#125; &lt;/script&gt; &lt;!--向上滚动代码结束--&gt; &lt;!--下面是向下滚动代码--&gt; &lt;div id=\"colee_bottom\" style=\"overflow:hidden;height:253px;width:410px;\"&gt; &lt;div id=\"colee_bottom1\"&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id=\"colee_bottom2\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var speed = 30 var colee_bottom2 = document.getElementById(\"colee_bottom2\"); var colee_bottom1 = document.getElementById(\"colee_bottom1\"); var colee_bottom = document.getElementById(\"colee_bottom\"); colee_bottom2.innerHTML = colee_bottom1.innerHTML colee_bottom.scrollTop = colee_bottom.scrollHeight function Marquee2() &#123; if (colee_bottom1.offsetTop - colee_bottom.scrollTop &gt;= 0) colee_bottom.scrollTop += colee_bottom2.offsetHeight else &#123; colee_bottom.scrollTop-- &#125; &#125; var MyMar2 = setInterval(Marquee2, speed) colee_bottom.onmouseover = function() &#123; clearInterval(MyMar2) &#125; colee_bottom.onmouseout = function() &#123; MyMar2 = setInterval(Marquee2, speed) &#125; &lt;/script&gt; &lt;!--向下滚动代码结束--&gt; &lt;!--下面是向左滚动代码--&gt; &lt;div id=\"colee_left\" style=\"overflow:hidden;width:500px;\"&gt; &lt;table cellpadding=\"0\" cellspacing=\"0\" border=\"0\"&gt; &lt;tr&gt; &lt;td id=\"colee_left1\" valign=\"top\" align=\"center\"&gt; &lt;table cellpadding=\"2\" cellspacing=\"0\" border=\"0\"&gt; &lt;tr align=\"center\"&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;td id=\"colee_left2\" valign=\"top\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; //使用div时，请保证colee_left2与colee_left1是在同一行上. var speed = 30 //速度数值越大速度越慢 var colee_left2 = document.getElementById(\"colee_left2\"); var colee_left1 = document.getElementById(\"colee_left1\"); var colee_left = document.getElementById(\"colee_left\"); colee_left2.innerHTML = colee_left1.innerHTML function Marquee3() &#123; if (colee_left2.offsetWidth - colee_left.scrollLeft &lt;= 0) //offsetWidth 是对象的可见宽度 colee_left.scrollLeft -= colee_left1.offsetWidth //scrollWidth 是对象的实际内容的宽，不包边线宽度 else &#123; colee_left.scrollLeft++ &#125; &#125; var MyMar3 = setInterval(Marquee3, speed) colee_left.onmouseover = function() &#123; clearInterval(MyMar3) &#125; colee_left.onmouseout = function() &#123; MyMar3 = setInterval(Marquee3, speed) &#125; &lt;/script&gt; &lt;!--向左滚动代码结束--&gt; &lt;!--下面是向右滚动代码--&gt; &lt;div id=\"colee_right\" style=\"overflow:hidden;width:500px;\"&gt; &lt;table cellpadding=\"0\" cellspacing=\"0\" border=\"0\"&gt; &lt;tr&gt; &lt;td id=\"colee_right1\" valign=\"top\" align=\"center\"&gt; &lt;table cellpadding=\"2\" cellspacing=\"0\" border=\"0\"&gt; &lt;tr align=\"center\"&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;td&gt; &lt;p&gt;&lt;img src=\"https://images.unsplash.com/profile-1495388545592-e4e376925c59?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;fit=crop&amp;h=64&amp;w=64&amp;s=12ae79a24d842721d9a2e3969a24c1f8\"&gt;&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;td id=\"colee_right2\" valign=\"top\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; var speed = 30 //速度数值越大速度越慢 var colee_right2 = document.getElementById(\"colee_right2\"); var colee_right1 = document.getElementById(\"colee_right1\"); var colee_right = document.getElementById(\"colee_right\"); colee_right2.innerHTML = colee_right1.innerHTML function Marquee4() &#123; if (colee_right.scrollLeft &lt;= 0) colee_right.scrollLeft += colee_right2.offsetWidth else &#123; colee_right.scrollLeft-- &#125; &#125; var MyMar4 = setInterval(Marquee4, speed) colee_right.onmouseover = function() &#123; clearInterval(MyMar4) &#125; colee_right.onmouseout = function() &#123; MyMar4 = setInterval(Marquee4, speed) &#125; &lt;/script&gt; &lt;!--向右滚动代码结束--&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"demo","slug":"demo","permalink":"http://yoursite.com/tags/demo/"}]},{"title":"循环","date":"2017-07-04T06:02:56.000Z","path":"2017/07/04/循环/","text":"JS中循环嵌套常见的六大经典例题+六大图形题首先，了解一下循环嵌套的特点：外层循环转一次，内层循环转一圈。在上一篇随笔中详细介绍了JS中的分支结构和循环结构，我们来简单的回顾一下For循环结构： for循环有三个表达式，分别为： ①定义循环变量② 判断循环条件③更新循环变量（三个表达式之间，用;分隔。）for循环三个表达式可以省略，两个;缺一不可 ##2、for循环特点：先判断，再执行；##3、for循环三个表达式，均可以有多部分组成，之间用逗号分隔，但是第二部分判断条件需要用&amp;&amp;链接，最终结果需要为真/假。##【嵌套循环特点】外层循环控制行数，内层循环控制每行元素个数 [做图形题思路]（图形题请看案例三） 1、确定图形一共几行，即为外层的循环的次数；2、确定每行有几种元素，代表有几个内层循环；3、确定没种元素的个数，即为每个内层循环的次数；Tips：通常，找出每种元素个数，与行号的关系式，即为当前内层循环的最大值（从1开始循环） 例题如下： 案例一 求和，实现 1+（1+2）+（1+2+3）+（1+2+3+4）+（1+2+3+4+5）=35 代码如下： 12345678910111213141516171819var sum = 0, sumRow = 0;for (var i = 1; i &lt;= 5; i++) &#123; sumRow = 0; if (i != 1) document.write(\"(\"); for (var j = 1; j &lt;= i; j++) &#123; if (j != i) document.write(j + \"+\"); else document.write(j); sumRow += j; &#125; if (i == 1) document.write(\"+\"); else if (i == 5) document.write(\")=\"); else document.write(\")+\"); sum += sumRow;&#125;document.write(sum); 案例二 求和：实现1!+2!+3!+4!+5! 分析1+12+123+1234+12345= 代码如下： 123456789var sum = 0;for (var i = 1; i &lt;= 5; i++) &#123; var jie = 1; for (var j = 1; j &lt;= i; j++) &#123; jie *= j; &#125; sum += jie;&#125;document.write(\"1!+2!+3!+4!+5!=\" + sum); ##案例三：（六大图形题） ###1、矩形 代码如下： 12345678for(var i=1;i&lt;=5;i++)&#123; for(var j=1;j&lt;=5;j++)&#123; document.write(\"*\"); &#125; document.write(\"&lt;br /&gt;\");&#125;document.write(\"&lt;hr /&gt;\"); 实现效果： 2、直角三角形代码如下： 12345678for(var i=1;i&lt;=5;i++)&#123; for(var j=1;j&lt;=i;j++)&#123; document.write(\"*\"); &#125; document.write(\"&lt;br /&gt;\");&#125; document.write(\"&lt;hr /&gt;\"); 实现效果： 3、平行三角形代码如下： 123456789for(var i=1;i&lt;=5;i++)&#123; for(var j=1;j&lt;=i+4;j++)&#123; if(j&lt;i)document.write(\"&amp;nbsp;\"); else&#123;document.write(\"*\");&#125; &#125; document.write(\"&lt;br /&gt;\");&#125;document.write(\"&lt;hr /&gt;\"); 效果如下： 4、数字等边三角形代码如下： 12345678910111213141516171819202122for(var i=1;i&lt;=4;i++)&#123; // 空格 for(var k=1;k&lt;=4-i;k++)&#123; document.write(\"&lt;span style='display: inline-block;width: 8px;'&gt;&lt;/span&gt;\"); &#125; var n = 1; // 递增 for(var j=1;j&lt;=i;j++)&#123; document.write(n); n++; &#125; n-=2; // 递减 for(var m=1;m&lt;=i-1;m++)&#123; document.write(n); n--; &#125; // 回车 document.write(\"&lt;br/&gt;\");&#125;document.write(\"&lt;hr /&gt;\"); 效果如下： 九九乘法表（以table表格的形式打印）代码如下: 1234567891011document.write(\"&lt;table width='700'&gt;\")for(var i=1;i&lt;=9;i++)&#123; document.write(\"&lt;tr&gt;\") for(var j=1;j&lt;=i;j++)&#123; document.write(\"&lt;td&gt;\"+i+\"*\"+j+\"=\"+i*j+\"&lt;/td&gt;\"); &#125; document.write(\"&lt;/tr&gt;\")&#125;document.write(\"&lt;/table&gt;\")document.write(\"&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;\"); 效果如下: 案例四输入一个数字，然后判断是否为正整数，如果不是，提示重新输入；如果是，将该数字左右反转，然后输出（例如：12345，翻转之后为54321）代码如下： 1234567891011121314151617181920212223var sum=1;for(var i=1;i&lt;=2;)&#123; var num = prompt(\"请输入一个数字~\"); if(Number(num)&gt;0&amp;&amp;parseInt(num)==parseFloat(num))&#123; break; &#125;&#125;/* num = 12345 5 num%10; 4 num/10%10; 3 num/10/10%10; ……*/document.write(\"您输入的数字为：\"+num+\"&lt;br /&gt;\"); for(j=1;;j++)&#123; sum *= 10; var fz = parseInt(num%sum/(sum/10)); document.write(fz); if(num-sum&lt;=0)&#123; break; &#125;&#125; 实现效果: 案例五 编写一个程序，最多接受10个数字，并求出其中所有正数的和。用户可通过输入999终止程序，统计出用户输入的正数个数，并显示这些正数的和。 分析 ①输入非数值，不占用10次机会之一，但要求重新输入；②输入的是数值，只累加整数；判断是否为一个数字：Number（num）不为NaN，说明为数字判断一个数字为正数：Number(num)&gt;0判断一个数字为整数：parseInt(num)==parseFloat(num); 代码如下： 123456789101112131415161718var i=1,sum=0,n=0;while(i&lt;=3)&#123; var num = prompt(\"请您输入一个数，我会为您计算出所有正数的和~\"); if(Number(num))&#123; if(num==999)&#123; break; &#125; else if(num&gt;=0)&#123; sum = sum + parseFloat(num); i++; n++; &#125; else if(num&lt;0)&#123; i++; &#125; &#125; &#125;document.write(\"您一共输入\"+n+\"个正整数\"+\"&lt;br /&gt;它们的和为：\"+sum); 案例六 输入某年某月某日，判断这一天是这一年的第几天？代码如下：方法一： 123456789101112131415for(var i=1;i&lt;month;i++)&#123; if(i==1||i==3||i==5||i==7||i==8||i==10||i==12)&#123; sum += 31; &#125;else if(i==4||i==6||i==9||i==11)&#123; sum += 30; &#125;else if(i==28)&#123; sum += 28; &#125;&#125; if((year%4==0&amp;&amp;year%100!=0||year%400==0)&amp;&amp;month&gt;2)&#123; sum += (day+1); &#125;else&#123; sum += day; &#125; document.write(\"您输入的日期为\"+year+\"-\"+month+\"-\"+day+\"&lt;br /&gt;为该年的第\"+sum+\"天\"); 方法二： 1234567891011121314151617181920212223242526272829303132333435363738 var year = parseInt(prompt(\"请输入年份：\"));var month = parseInt(prompt(\"请输入月份：\"));var day = parseInt(prompt(\"请输入日期：\"));/*假设都是平年，2月28天*/var sum = 0;switch(month-1)&#123; case 12: sum += 31; case 11: sum += 30; case 10: sum += 31; case 9: sum += 30; case 8: sum += 31; case 7: sum += 31; case 6: sum += 30; case 5: sum += 31; case 4: sum += 30; case 3: sum += 31; case 2: sum += 28; case 1: sum += 31; &#125; if((year%4==0&amp;&amp;year%100!=0||year%400==0)&amp;&amp;month&gt;2)&#123; sum += (day+1); &#125;else&#123; sum += day; &#125; document.write(\"您输入的日期为\"+year+\"-\"+month+\"-\"+day+\"&lt;br /&gt;为该年的第\"+sum+\"天\"); 案例七 假设一个简单的ATM机的取款过程是这样的：首先提示用户输入密码（password），最多只能输入三次，超过3次则提示用户“密码错误，请取卡”结束交易。如果用户密码正确，再提示用户输入取款金额（amount），ATM机只能输出100元的纸币，一次取钱数要求最低100元，最高1000元。若用户输入的金额符合上述要求，则打印输出用户取得钱数，最后提示用户“交易完成，请取卡”，否则提示用户重新输入金额。假设用户密码是111111，请编程实现。 代码如下： 12345678910111213141516171819202122232425262728var isTrue = false, n = 1;while(n &lt;= 3) &#123; var pwd = prompt(\"请输入用户密码~\"); if(pwd == 111111) &#123; isTrue = true; break; &#125; else &#123; n++; if(n &gt; 3) &#123; document.write(\"密码错误，请取卡!\"); &#125; &#125; &#125; if(isTrue) &#123; while(1) &#123; var num = prompt(\"请输入取款金额：(100~1000元)\") if(num % 100 == 0 &amp;&amp; num &gt;= 0 &amp;&amp; num &lt;= 1000) &#123; document.write(\"您的取款金额为\" + num + \"元~&lt;br /&gt;交易完成，请取卡！\"); break; &#125; else &#123; alert(\"你输入不合法！请重新输入！\") &#125; &#125; //循环输入金额操作 &#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"有意思的js循环","date":"2017-07-04T03:54:09.000Z","path":"2017/07/04/有意思的js循环/","text":"循环菱形***有意思的各种log圣兽 1234567891011121314151617181920212223242526272829303132333435363738function Printfile() &#123; var num = prompt(\"请输入菱形的边长(单击确定之后会看到以*为单位长度组成的菱形)\"); for (var i = 1; i &lt;= num; i++) //决定输出的行数 &#123; for (var j = 1; j &lt;= num - i; j++) //决定每一行开头的空格数 &#123; document.write(\"&amp;nbsp\"); &#125; for (var k = 1; k &lt;= 2 * i - 1; k++) //决定每一行的*数 &#123; document.write(\"*\"); &#125; document.write(\"&lt;/br&gt;\"); &#125; for (var i = 1; i &lt;= num - 1; i++) //决定输出的行数 &#123; for (var j = 1; j &lt;= i; j++) //决定每一行开头的空格数 &#123; document.write(\"&amp;nbsp\"); &#125; for (var k = 1; k &lt;= 2 * num - 1 - 2 * i; k++) //决定每一行的*数 &#123; document.write(\"*\"); &#125; document.write(\"&lt;/br&gt;\"); &#125;&#125;Printfile(); * *** ***** **************** ******* ***** *** * 佛祖保佑，代码无BUG1234567891011121314151617181920212223242526272829303132333435363738394041424344* *----------Dragon be here!----------/ * ┏┓ ┏┓ * ┏┛┻━━━━━━┛┻┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ┳┛ ┗┳ ┃ * ┃ ┃ * ┃ ┻ ┃ * ┃ ┃ * ┗━┓ ┏━┛ * ┃ ┃神兽保佑 * ┃ ┃代码无BUG！ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ * ━━━━━━神兽出没━━━━━━ _ooOoo_ o8888888o 88\" . \"88 (| -_- |) O\\ = /O ____/`---'\\____ .' \\\\| |// `. / \\\\||| : |||// \\ / _||||| -:- |||||- \\ | | \\\\\\ - /// | | | \\_| ''\\---/'' | | \\ .-\\__ `-` ___/-. / ___`. .' /--.--\\ `. . __ .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\". | | : ` - `.;`\\ _ /`;.`/ - ` : | | \\ \\ `-. \\_ __\\ /__ _/ .-` / /======`-.____`-.___\\_____/___.-`____.-'====== `=---='^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG 空菱形1234567891011121314151617181920212223242526272829303132333435var blank = 4;for (i = 1; i &lt;= 17; i++) &#123; if (i % 2 != 0) &#123; for (j = 1; j &lt;= Math.abs(blank); j++) &#123; document.write(\"_\"); &#125; blank--; document.write(\"*\"); if (i != 1 &amp;&amp; i != 17) &#123; if (i &lt;= 9) &#123; for (k = 1; k &lt;= i - 2; k++) &#123; document.write(\"_\"); &#125; &#125; else &#123; for (k = 1; k &lt;= 16 - i; k++) &#123; document.write(\"_\"); &#125; &#125; document.write(\"*\") &#125; &#125; else &#123; document.write(\"&lt;br /&gt;\"); &#125;&#125; * * * * * * ** * * * * * * * *","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"掘金","date":"2017-07-03T03:34:44.000Z","path":"2017/07/03/掘金/","text":"前端数据结构与算法1.递归 递归就是自己调自己，递归在前端里面算是一种比较常用的算法。假设现在有一堆数据要处理，要实现上一次请求完成了，才能去调下一个请求。一个是可以用Promise，就像《前端与SQL》这篇文章里面提到的。但是有时候并不想引入Promise，能简单处理先简单处理。这个时候就可以用递归，如下代码所示： 123456789101112131415var ids = [34112, 98325, 68125];(function sendRequest()&#123; var id = ids.shift(); if(id)&#123; console.log(id); sendRequest(); &#125; else &#123; console.log(\"finished\"); &#125;&#125;)(); //34112//98325//68125//finished 上面代码定义了一个sendRequest的函数，在请求完成之后再调一下自己。每次调之前先取一个数据，如果数组已经为空，则说明处理完了。这样就用简单的方式实现了串行请求不堵塞的功能。厉害 再来讲另外一个场景：DOM树。 由于DOM是一棵树，而树的定义本身就是用的递归定义，所以用递归的方法处理树，会非常地简单自然。例如用递归实现一个查DOM的功能document.getElementById。 12345678910function getElementById(node, id)&#123; if(!node) return null; if(node.id === id) return node; for(var i = 0; i &lt; node.childNodes.length; i++)&#123; var found = getElementById(node.childNodes[i], id); if(found) return found; &#125; return null;&#125;getElementById(document, \"d-cal\"); document是DOM树的根结点，一般从document开始往下找。在for循环里面先找document的所有子结点，对所有子结点递归查找他们的子结点，一层一层地往下查找。如果已经到了叶子结点了还没有找到，则在第二行代码的判断里面返回null，返回之后for循环的i加1，继续下一个子结点。如果当前结点的id符合查找条件，则一层层地返回。所以这是一个深度优先的遍历，每次都先从根结点一直往下直到叶子结点，再从下往上返回。最后在控制台验证一下，执行结果如下图所示：使用递归的优点是代码简单易懂，缺点是效率比不上非递归的实现。Chrome浏览器的查DOM是使用非递归实现。非递归要怎么实现呢？如下代码： 12345678function getByElementId(node, id)&#123; //遍历所有的Node while(node)&#123; if(node.id === id) return node; node = nextElement(node); &#125; return null;&#125; 还是依次遍历所有的DOM结点，只是这一次改成一个while循环，函数nextElement负责找到下一个结点。所以关键在于这个nextElement如何非递归实现，如下代码所示： 123456789101112131415function nextElement(node)&#123; if(node.children.length) &#123; return node.children[0]; &#125; if(node.nextElementSibling)&#123; return node.nextElementSibling; &#125; while(node.parentNode)&#123; if(node.parentNode.nextElementSibling) &#123; return node.parentNode.nextElementSibling; &#125; node = node.parentNode; &#125; return null;&#125; 还是用深度遍历，先找当前结点的子结点，如果它有子结点，则下一个元素就是它的第一个子结点，否则判断它是否有相邻元素，如果有则返回它的下一个相邻元素。如果它既没有子结点，也没有下一个相邻元素，则要往上返回它的父结点的下一个相邻元素，相当于上面递归实现里面的for循环的i加1. 在控制台里面运行这段代码，同样也可以正确地输出结果。不管是非递归还是递归，它们都是深度优先遍历，这个过程如下图所示。实际上getElementById浏览器是用的一个哈希map存储的，根据id直接映射到DOM结点，而getElementsByClassName就是用的这样的非递归查找。 上面是单个选择器的查找，按id，按class等，多个选择器应该如何查找呢？ 2. 复杂选择器的查DOM如实现一个document.querySelector： 1document.querySelector(\".mls-info &gt; div .copyright-content\") 首先把复杂选择器做一个解析，序列为以下格式： 12345//把selector解析为var selectors = [&#123;relation: \"descendant\", matchType: \"class\", value: \"copyright-content\"&#125;,&#123;relation: \"child\", matchType: \"tag\", value: \"div\"&#125;,&#123;relation: \"subSelector\", matchType: \"class\", value: \"mls-info\"&#125;]; 从右往左，第一个selector是.copyright-content，它是一个类选择器，所以它的matchType是class，它和第二个选择器是祖先和子孙关系，因此它的relation是descendant；同理第二个选择器的matchType是tag，而relation是child，表示是第三个选择器的直接子结点；第三个选择器也是class，但是它没有下一个选择器了，relation用subSelector表示。 matchType的作用就在于用来比较当前选择器是否match，如下代码所示： 123456789101112131415function match(node, selector)&#123; if(node === document) return false; switch(selector.matchType)&#123; //如果是类选择器 case \"class\": return node.className.trim().split(/ +/).indexOf(selector.value) &gt;= 0; //如果是标签选择器 case \"tag\": return node.tagName.toLowerCase() === selector.value. toLowerCase(); default: throw \"unknown selector match type\"; &#125;&#125; 根据不同的matchType做不同的匹配。 在匹配的时候，从右往左，依次比较每个选择器是否match. 在比较下一个选择器的时候，需要找到相应的DOM结点，如果当前选择器是下一个选择器的子孙时，则需要比较当前选择器所有的祖先结点，一直往上直到document；而如果是直接子元素的关系，则比较它的父结点即可。所以需要有一个找到下一个目标结点的函数： 1234567891011121314function nextTarget(node, selector)&#123; if(!node || node === document) return null; switch(selector.relation)&#123; case \"descendant\": return &#123;node: node.parentNode, hasNext: true&#125;; case \"child\": return &#123;node: node.parentNode, hasNext: false&#125;; case \"sibling\": return &#123;node: node.previousSibling, hasNext: true&#125;; default: throw \"unknown selector relation type\"; //hasNext表示当前选择器relation是否允许继续找下一个节点 &#125;&#125; 有了nextTarge和match这两个函数就可以开始遍历DOM，如下代码所示： 最外层的while循环和简单选择器一样，都是要遍历所有DOM结点。对于每个结点，先判断第一个选择器是否match，如果不match的话，则继续下一个结点，如果不是标签选择器，对于绝大多数结点将会在这里判断不通过。如果第一个选择器match了，则根据第一个选择器的relation，找到下一个target，判断下一个targe是否match下一个selector，只要有一个target匹配上了，则退出里层的while循环，继续下一个选择器，如果所有的selector都能匹配上说明匹配成功。如果有一个selecotr的所有target都没有match，则说明匹配失败，退出selector的for循环，直接从头开始对下一个DOM结点进行匹配。 这样就实现了一个复杂选择器的查DOM。写这个的目的并不是要你自己写一个查DOM的函数拿去用，而是要明白查DOM的过程是怎么样的，可以怎么实现，浏览器又是怎么实现的。还有可以怎么遍历DOM树，当明白这个过程的时候，遇到类似的问题，就可以举一反三。 最后在浏览器上运行一下，如下图所示： 重复值处理现在有个问题，如下图所示： 当地图往下拖的时候要更新地图上的房源标签数据，上图绿框表示不变的标签，而黄框表示新加的房源。 后端每次都会把当前地图可见区域的房源返回给我，当用户拖动的时候需要知道哪些是原先已经有的房源，哪些是新加的。把新加的房源画上，而把超出区域的房源删掉，已有的房源保持不动。因此需要对比当前房源和新的结果哪些是重复的。因为如果不这样做的话，改成每次都是全部删掉再重新画，已有的房源标签就会闪一下。因此为了避免闪动做一个增量更新。 把这个问题抽象一下就变成：给两个数组，需要找出第一个数组里面的重复值和非重复值。即有一个数组保存上一次状态的房源，而另一个数组是当前状态的新房源数据。找到的重复值是需要保留，找到非重复值是要删掉的。 最直观的方法是使用双重循环。 （1）双重循环如下代码所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var lastHouses = [];filterHouse: function(houses)&#123; if(lastHouses === null)&#123; lastHouses = houses; return &#123; remainsHouses: [], newHouses: houses &#125;; &#125; var remainsHouses = [], newHouses = []; for(var i = 0; i &lt; houses.length; i++)&#123; var isNewHouse = true; for(var j = 0; j &lt; lastHouses.length; j++)&#123; if(houses[i].id === lastHouses[j].id)&#123; isNewHouse = false; remainsHouses.push(lastHouses[j]); break; &#125; &#125; if(isNewHouse)&#123; newHouses.push(houses[i]); &#125; &#125; lastHouses = remainsHouses.concat(newHouses); return &#123; remainsHouses: remainsHouses, newHouses: newHouses &#125;; &#125;var lastHouses = [];filterHouse: function(houses)&#123; if(lastHouses === null)&#123; lastHouses = houses; return &#123; remainsHouses: [], newHouses: houses &#125;; &#125; var remainsHouses = [], newHouses = []; for(var i = 0; i &lt; houses.length; i++)&#123; var isNewHouse = true; for(var j = 0; j &lt; lastHouses.length; j++)&#123; if(houses[i].id === lastHouses[j].id)&#123; isNewHouse = false; remainsHouses.push(lastHouses[j]); break; &#125; &#125; if(isNewHouse)&#123; newHouses.push(houses[i]); &#125; &#125; lastHouses = remainsHouses.concat(newHouses); return &#123; remainsHouses: remainsHouses, newHouses: newHouses &#125;; &#125; 上面代码有一个双重for循环，对新数据的每个元素，判断老数据里面是否已经有了，如果有的话则说明是重复值，如果老数据循环了一遍都没找到，则说明是新数据。由于用到了双重循环，所以这个算法的时间复杂度为O(N2)，对于百级的数据还好，对于千级的数据可能会有压力，因为最坏情况下要比较1000000次。 （2）使用set如下代码所示： 1234567891011121314151617var lastHouses = new Set();function filterHouse(houses)&#123; var remainsHouses = [], newHouses = []; for(var i = houses.length - 1; i &gt;= 0; i--)&#123; if(lastHouses.has(houses[i].id))&#123; remainsHouses.push(houses[i]); &#125; else &#123; newHouses.push(houses[i]); &#125; &#125; for(var i = 0; i &lt; newHouses.length; i++)&#123; lastHouses.add(newHouses[i].id); &#125; return &#123;remainsHouses: remainsHouses, newHouses: newHouses&#125;;&#125; 老数据的存储lastHouses从数组改成set，但如果一开始就是数组呢，就像问题抽象里面说的给两个数组？那就用这个数组的数据初始化一个Set. 使用Set和使用Array的区别在于可以减少一重循环，调用Set.prototype.has的函数。Set一般是使用红黑树实现的，红黑树是一种平衡查找二叉树，它的查找时间复杂度为O(logN)。所以时间上进行了改进，从O(N)变成O(logN)，而总体时间从O(N2)变成O(NlogN)。实际上，Chrome V8的Set是用哈希实现的，它是一个哈希Set，查找时间复杂度为O(1)，所以总体的时间复杂度是O(N). 不管是O(NlogN)还是O(N)，表面上看它们的时间要比O(N2)的少。但实际上需要注意的是它们前面还有一个系数。使用Set在后面更新lastHouses的时候也是需要时间的： 123for(var i = 0; i &lt; newHouses.length; i++)&#123; lastHouses.add(newHouses[i].id);&#125; 如果Set是用树的实现，这段代码是时间复杂度为O(NlogN)，所以总的时间为O(2NlogN)，但是由于大O是不考虑系数的，O(2NlogN) 还是等于O(NlogN)，当数据量比较小的时侯，这个系数会起到很大的作用，而数据量比较大的时候，指数级增长的O(N2)将会远远超过这个系数，哈希的实现也是同样道理。所以当数据量比较小时，如只有一两百可直接使用双重循环处理即可。上面的代码有点冗长，我们可以用ES6的新特性改写一下，变得更加的简洁： 12345678function filterHouse(houses)&#123; var remainsHouses = [], newHouses = []; houses.map(house =&gt; lastHouses.has(house.id) ? remainsHouses.push(house) : newHouses.push(house)); newHouses.map(house =&gt; lastHouses.add(house.id)); return &#123;remainsHouses, newHouses&#125;;&#125;","tags":[{"name":"掘金","slug":"掘金","permalink":"http://yoursite.com/tags/%E6%8E%98%E9%87%91/"}]},{"title":"hexo-Markdown语法","date":"2017-06-29T06:52:04.000Z","path":"2017/06/29/Markdown/","text":"123456超链接： [链接文字](链接地址);图片： ![图片说明](图片地址);~~~type（js,html,css） 内容 ~","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Vue-components","date":"2017-06-29T06:43:52.000Z","path":"2017/06/29/Vue-components/","text":"组件系统什么是组件？ 组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 使用组件注册之前还说过，我们可以通过一下方式创建一个Vue实例： 1234new Vue(&#123; el: '#some-element', // 选项&#125;) 要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如： 123Vue.component('my-component', &#123; // 选项&#125;) 对于自定义标签名，Vue.js 不强制要求遵循 W3C规则 （小写，并且包含一个短杠），尽管遵循这个规则比较好。 组件在注册之后，便可以在父实例的模块中以自定义元素 的形式使用。要确保在初始化根实例 之前 注册了组件： 123&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 12345678// 注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;) 渲染为： 123&lt;div id=\"example\"&gt; &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt; 局部注册不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用： 12345678910var Child = &#123;template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;new Vue(&#123;// ...components: &#123; // &lt;my-component&gt; 将只在父模板可用 'my-component': Child&#125;&#125;) 这种封装也适用于其它可注册的 Vue 功能，如指令。 DOM模型解析说明当使用 DOM 作为模版时（例如，将 el 选项挂载到一个已存在的元素上）, 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。尤其像这些元素 ，， ， 限制了能被它包裹的元素， 而一些像 这样的元素只能出现在某些其它元素内部。在自定义组件中使用这些受限制的元素时会导致一些问题，例如： 123&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; 自定义组件 被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 is 属性： 123&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt;&lt;/table&gt; 应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用： &lt; script type=”text/x-template”&gt; JavaScript内联模版字符串 .vue 组件 因此，有必要的话请使用字符串模版。 data必须是函数通过Vue构造器传入的各种选项大多数都可以在组件里用。 data 是一个例外，它必须是函数。 实际上，如果你这么做： 123456Vue.component('my-component', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: &#123; message: 'hello' &#125;&#125;) 那么 Vue 会停止，并在控制台发出警告，告诉你在组件中 data 必须是一个函数。理解这种规则的存在意义很有帮助，让我们假设用如下方式来绕开Vue的警告： 12345&lt;div id=\"example-2\"&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt; &lt;simple-counter&gt;&lt;/simple-counter&gt;&lt;/div&gt; 123456789101112var data = &#123; counter: 0 &#125;Vue.component('simple-counter', &#123; template: '&lt;button v-on:click=\"counter += 1\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', // 技术上 data 的确是一个函数了，因此 Vue 不会警告， // 但是我们返回给每个组件的实例的却引用了同一个data对象 data: function () &#123; return data &#125;&#125;)new Vue(&#123; el: '#example-2'&#125;) 由于这三个组件共享了同一个 data ， 因此增加一个 counter 会影响所有组件！这不对。我们可以通过为每个组件返回全新的 data 对象来解决这个问题： 12345data: function () &#123; return &#123; counter: 0 &#125;&#125; 现在每个 counter 都有它自己内部的状态了 构成组件组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。看看它们是怎么工作的。 Prop使用Prop传递数据组件实例的作用域是孤立的。这意味着不能(也不应该)在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的props选项。子组件要显式地用 props 选项声明它期待获得的数据： 1234567Vue.component('child', &#123;// 声明 propsprops: ['message'],// 就像 data 一样，prop 可以用在模板内// 同样也可以在 vm 实例中像 “this.message” 这样使用template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;) 然后我们可以这样向它传入一个普通字符串： 1&lt;child message=\"hello!\"&gt;&lt;/child&gt; camelCase vs. kebab-caseHTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名： 12345Vue.component('child', &#123; // camelCase in JavaScript props: ['myMessage'], template: '&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'&#125;) 12&lt;!-- kebab-case in HTML --&gt;&lt;child my-message=\"hello!\"&gt;&lt;/child&gt; 如果你使用字符串模版，则没有这些限制。 动态Prop在模板中，要动态地绑定父组件的数据到子模板的props，与绑定到任何普通的HTML特性相类似，就是用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件： 12345&lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt;&lt;/div&gt; 使用 v-bind 的缩写语法通常更简单： 1&lt;child :my-message=\"parentMsg\"&gt;&lt;/child&gt; 字面量语法-vs-动态语法初学者常犯的一个错误是使用字面量语法传递数值： 12&lt;!-- 传递了一个字符串 \"1\" --&gt;&lt;comp some-prop=\"1\"&gt;&lt;/comp&gt; 因为它是一个字面 prop ，它的值是字符串 “1” 而不是number。如果想传递一个实际的number，需要使用 v-bind ，从而让它的值被当作 JavaScript 表达式计算： 12&lt;!-- 传递实际的 number --&gt;&lt;comp v-bind:some-prop=\"1\"&gt;&lt;/comp&gt; 单项数据流prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。为什么我们会有修改prop中数据的冲动呢？通常是这两种原因： prop 作为初始值传入后，子组件想把它当作局部数据来用； prop 作为初始值传入，由子组件处理成其它数据输出。 对这两种原因，正确的应对方式是：1.定义一个局部变量，并用 prop 的值初始化它： 1234props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 2.定义一个计算属性，处理 prop 的值并返回。 123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 Prop验证我们可以为组件的 props 指定验证规格。如果传入的数据不符合规格，Vue 会发出警告。当组件给其他人使用时，这很有用。要指定验证规格，需要用对象的形式，而不能用字符串数组： 12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组／对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125; &#125;) type 可以是下面原生构造器： String Number Boolean Function Object Arraytype 也可以是一个自定义构造器函数，使用 instanceof 检测。当 prop 验证失败，Vue会在抛出警告 (如果使用的是开发版本)。自定义事件我们知道，父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！使用-v-on-绑定自定义事件每个 Vue 实例都实现了事件接口(Events interface)，即：使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件 Vue的事件系统分离自浏览器的EventTarget API。尽管它们的运行类似，但是$on 和 $emit 不是addEventListener 和 dispatchEvent 的别名。 另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。 不能用$on侦听子组件抛出的事件，而必须在模板里直接用v-on绑定，就像以下的例子： 下面是一个例子： 12345&lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt;&lt;/div&gt; 12345678910111213141516171819202122232425Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;, &#125;) new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;) 在本例中，子组件已经和它外部完全解耦了。它所做的只是报告自己的内部事件，至于父组件是否关心则与它无关。留意到这一点很重要。给组件绑定原生事件 有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on 。例如： 1&lt;my-component v-on:click.native=\"doTheThing\"&gt;&lt;/my-component&gt; sync-修饰符 2.3.0+ 在一些情况下，我们可能会需要对一个 prop 进行『双向绑定』。事实上，这正是 Vue 1.x 中的 .sync修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了『单向数据流』的假设。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。上面所说的正是我们在 2.0 中移除 .sync 的理由。但是在 2.0 发布之后的实际应用中，我们发现 .sync 还是有其适用之处，比如在开发可复用的组件库时。我们需要做的只是让子组件改变父组件状态的代码更容易被区分。在 2.3 我们重新引入了 .sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。如下代码 1&lt;comp :foo.sync=\"bar\"&gt;&lt;/comp&gt; 会被扩展为： 1&lt;comp :foo=\"bar\" @update:foo=\"val =&gt; bar = val\"&gt;&lt;/comp&gt; 当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件： 1this.$emit('update:foo', newValue) 使用自定义事件的表单输入组件自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。看看这个： 1&lt;input v-model=\"something\"&gt; 这不过是以下示例的语法糖： 1&lt;input v-bind:value=\"something\" v-on:input=\"something = $event.target.value\"&gt; 所以在组件中使用时，它相当于下面的简写： 1&lt;custom-input v-bind:value=\"something\" v-on:input=\"something = arguments[0]\"&gt;&lt;/custom-input&gt; 所以要让组件的 v-model 生效，它必须：接受一个 value 属性在有新的 value 时触发 input 事件我们来看一个非常简单的货币输入的自定义控件： 1&lt;currency-input v-model=\"price\"&gt;&lt;/currency-input&gt; 1234567891011121314151617181920212223242526272829Vue.component('currency-input', &#123; template: '\\ &lt;span&gt;\\ $\\ &lt;input\\ ref=\"input\"\\ v-bind:value=\"value\"\\ v-on:input=\"updateValue($event.target.value)\"\\ &gt;\\ &lt;/span&gt;\\ ', props: ['value'], methods: &#123; // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制 updateValue: function (value) &#123; var formattedValue = value // 删除两侧的空格符 .trim() // 保留 2 小数位 .slice(0, value.indexOf('.') + 3) // 如果值不统一，手动覆盖以保持一致 if (formattedValue !== value) &#123; this.$refs.input.value = formattedValue &#125; // 通过 input 事件发出数值 this.$emit('input', Number(formattedValue)) &#125; &#125;&#125;) 当然，上面的例子是比较幼稚的。 比如，用户甚至可以输入多个小数点或句号 - 哦哦！因此我们需要一个更有意义的例子，下面是一个更加完善的货币过滤器： 1234567891011121314151617181920212223 &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.rawgit.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e/raw/974aa47f8f9c5361c5233bd56be37db8ed765a09/currency-validator.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;currency-input label=\"Price\" v-model=\"price\" &gt;&lt;/currency-input&gt; &lt;currency-input label=\"Shipping\" v-model=\"shipping\" &gt;&lt;/currency-input&gt; &lt;currency-input label=\"Handling\" v-model=\"handling\" &gt;&lt;/currency-input&gt; &lt;currency-input label=\"Discount\" v-model=\"discount\" &gt;&lt;/currency-input&gt; &lt;p&gt;Total: $&#123;&#123; total &#125;&#125;&lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Vue.component('currency-input', &#123; template: '\\ &lt;div&gt;\\ &lt;label v-if=\"label\"&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt;\\ $\\ &lt;input\\ ref=\"input\"\\ v-bind:value=\"value\"\\ v-on:input=\"updateValue($event.target.value)\"\\ v-on:focus=\"selectAll\"\\ v-on:blur=\"formatValue\"\\ &gt;\\ &lt;/div&gt;\\ ', props: &#123; value: &#123; type: Number, default: 0 &#125;, label: &#123; type: String, default: '' &#125; &#125;, mounted: function () &#123; this.formatValue() &#125;, methods: &#123; updateValue: function (value) &#123; var result = currencyValidator.parse(value, this.value) if (result.warning) &#123; this.$refs.input.value = result.value &#125; this.$emit('input', result.value) &#125;, formatValue: function () &#123; this.$refs.input.value = currencyValidator.format(this.value) &#125;, selectAll: function (event) &#123; // Workaround for Safari bug // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome setTimeout(function () &#123; event.target.select() &#125;, 0) &#125; &#125;&#125;)new Vue(&#123; el: '#app', data: &#123; price: 0, shipping: 0, handling: 0, discount: 0 &#125;, computed: &#123; total: function () &#123; return (( this.price * 100 + this.shipping * 100 + this.handling * 100 - this.discount * 100 ) / 100).toFixed(2) &#125; &#125;&#125;) 事件接口不仅仅可以用来连接组件内部的表单输入，也很容易集成你自己创造的输入类型。想象一下： 123&lt;voice-recognizer v-model=\"question\"&gt;&lt;/voice-recognizer&gt;&lt;webcam-gesture-reader v-model=\"gesture\"&gt;&lt;/webcam-gesture-reader&gt;&lt;webcam-retinal-scanner v-model=\"retinalImage\"&gt;&lt;/webcam-retinal-scanner&gt; 非父子组件通信有时候两个组件也需要通信(非父子关系)。在简单的场景下，可以使用一个空的 Vue 实例作为中央事件总线： 1var bus = new Vue() 12// 触发组件 A 中的事件bus.$emit('id-selected', 1) 1234// 在组件 B 创建的钩子中监听事件bus.$on('id-selected', function (id) &#123; // ...&#125;) 在复杂的情况下，我们应该考虑使用专门的 状态管理模式. 使用 Slot 分发内容在使用组件时，我们常常要像这样组合它们： 1234&lt;app&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;app-footer&gt;&lt;/app-footer&gt;&lt;/app&gt; 注意两点：1. 组件不知道它的挂载点会有什么内容。挂载点的内容是由的父组件决定的。2. 组件很可能有它自己的模版。为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 内容分发 (或 “transclusion” 如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API ，参照了当前 Web 组件规范草案，使用特殊的 元素作为原始内容的插槽。 编译作用域在深入内容分发 API 之前，我们先明确内容在哪个作用域里编译。假定模板为： 123&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法： 12&lt;!-- 无效 --&gt;&lt;child-component v-show=\"someChildProperty\"&gt;&lt;/child-component&gt; 假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。如果要绑定作用域内的指令到一个组件的根节点，你应当在组件自己的模板上做： 123456789Vue.component('child-component', &#123; // 有效，因为是在正确的作用域内 template: '&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125; &#125;&#125;) 类似地，分发内容是在父作用域内编译。 单个-Slot除非子组件模板包含至少一个 &lt;slot&gt; 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。最初在 &lt;slot&gt; 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。假定 my-component 组件有下面模板： 123456&lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;slot&gt; 只有在没有要分发的内容时才会显示。 &lt;/slot&gt;&lt;/div&gt; 父组件模版： 1234567&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt;&lt;/div&gt; 渲染结果： 12345678&lt;div&gt; &lt;h1&gt;我是父组件的标题&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;我是子组件的标题&lt;/h2&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 具名-Slot&lt;slot&gt; 元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。例如，假定我们有一个 app-layout 组件，它的模板为： 1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 父组件模版： 123456&lt;app-layout&gt; &lt;h1 slot=\"header\"&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;p slot=\"footer\"&gt;这里有一些联系信息&lt;/p&gt;&lt;/app-layout&gt; 渲染结果为： 123456789101112&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;主要内容的一个段落。&lt;/p&gt; &lt;p&gt;另一个主要段落。&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;这里有一些联系信息&lt;/p&gt; &lt;/footer&gt;&lt;/div&gt; 在组合组件时，内容分发 API 是非常有用的机制。 作用域插槽 2.1.0新增 作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样： 123&lt;div class=\"child\"&gt; &lt;slot text=\"hello from child\"&gt;&lt;/slot&gt;&lt;/div&gt; 在父级中，具有特殊属性 scope 的 &lt;template&gt; 元素，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象： 12345678&lt;div class=\"parent\"&gt; &lt;child&gt; &lt;template scope=\"props\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 如果我们渲染以上结果，得到的输出会是： 123456&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue-api","date":"2017-06-29T06:42:18.000Z","path":"2017/06/29/Vue-api/","text":"","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue","date":"2017-06-29T04:09:55.000Z","path":"2017/06/29/Vue/","text":"Vue介绍Vue.js 是什么 一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 简单起步 双向数据绑定，所有的元素都是响应式的。 1234567891011121314151617181920212223&lt;style&gt; [v-cloak]&#123; visibility: hidden; &#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125; &lt;span v-bind:title=\"message\"&gt;&lt;/span&gt; &lt;!-- Vue的数据绑定方法有： 双花括号：&#123;&#123;&#125;&#125; V开头的bind：v-bind --&gt;&lt;/div&gt;&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!'+ new Date() &#125; &#125;)&lt;/script&gt; Vue指令 看到的以v-开头的属性，被称为指令。v-bind，用处表示“将这个元素节点的title属性和Vue实例中的massage属性保持一致。可以简写为‘:’，:title。”v-on,指令监听 DOM 事件来触发一些 JavaScript 代码。可以简写为‘@’，@click 安装CDN 推荐：unpkg, 会保持和 npm 发布的最新的版本一致。可以在 unpkg.com/vue/ 浏览 npm 包资源。也可以从 jsdelivr 或 cdnjs 获取，不过这两个服务版本更新可能略滞后。 NPM 在用 Vue.js 构建大型应用时推荐使用 NPM 安装， NPM 能很好地和诸如 Webpack 或 Browserify 模块打包器配合使用。 Vue.js 也提供配套工具来开发单文件组件。 1$ npm install vue 构建方式概念 有两种构建方式，独立构建和运行构建。它们的区别在于前者包含模板编译器而后者不包含。 模板编译器 模板编译器的职责是将模板字符串编译为纯 JavaScript 的渲染函数。如果你想要在组件中使用 template 选项，你就需要编译器。 模板字符串：template####el 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。 template 一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发 slot。 render 字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。render 函数接收一个 createElement 方法作为第一个参数用来创建 VNode。 区别 独立构建包含模板编译器并支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。运行时构建不包含模板编译器，因此不支持 template 选项，只能用 render 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 render 函数。运行时构建比独立构建要轻量30%，只有 17.14 Kb min+gzip大小。 为什么要使用独立构建和运行时构建？ Vue.js 的运行过程实际上包含两步。第一步，编译器将字符串模板（template）编译为渲染函数（render），称之为编译过程；第二步，运行时实际调用编译的渲染函数，称之为运行过程由于 Vue.js 1.0 的编译过程需要依赖浏览器的 DOM，所以无法（或者说没有意义）将编译器和运行时分开。因此在 Vue.js 1.0 分发包中，编译器和运行时是打包在一起，都在浏览器端执行。然而到了 Vue.js 2.0，为了支持服务端渲染（server-side rendering），编译器不能依赖于 DOM，所以必须将编译器和运行时分开。这就形成了独立构建（编译器 + 运行时）和运行时构建（仅运行时）。显而易见，运行时构建要小于独立构建。在现代前端工程构建中，通常会使用 vue-loader 和 vueify 预编译模板。在这种情况下，只需要打包运行时，而不需要打包编译器，运行时构建即可满足所需。当然，如果你需要在前端使用 template 选项实时编译模板，那么还是需要使用独立构建将编译器发送到浏览器。 总结： 两种编译模式是为了服务器端渲染和浏览器执行两种不同环境产生的一般来讲独立构建适用于服务器端渲染浏览器 实际运行时为 运行时构建 但是如果需要在前端使用 template 选项实时编译模板，那么还是需要使用独立构建将编译器发送到浏览器。 命令行工具Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目： 12345678# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev 实例构造器123456var vm = new Vue(&#123; // 选项 el:'#app', data:&#123;&#125;, .....&#125;) 你可以在构造器的外部用vm来代表vm构造器 在实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。全部的选项可以在 API 文档中查看。 组件构造器12345var MyComponent = Vue.extend(&#123; // 扩展选项&#125;); // 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建var myComponentInstance = new MyComponent(); 尽管可以命令式地创建扩展实例，不过在多数情况下建议将组件构造器注册为一个自定义元素，然后声明式地用在模板中。我们将在后面详细说明组件系统。现在你只需知道所有的 Vue.js 组件其实都是被扩展的 Vue 实例。 属性和方法每个 Vue 实例都会代理其 data 对象里所有的属性： 1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123; data: data&#125;)vm.a === data.a // -&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // -&gt; 2// ... 反之亦然data.a = 3vm.a // -&gt; 3 注意只有这些被代理的属性是响应的。如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。我们将在后面详细讨论响应系统。除了 data 属性， Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分。例如： 1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data &#125;)vm.$data === data // -&gt; truevm.$el === document.getElementById('example') // -&gt; true// $watch 是一个实例方法vm.$watch('a', function (newVal, oldVal) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 注意，不要在实例属性或者回调函数中（如 vm.$watch(‘a’, newVal =&gt; this.myMethod())）使用箭头函数。因为箭头函数绑定父级上下文，所以 this 不会像预想的一样是 Vue 实例，而是 this.myMethod 未被定义。实例属性和方法的完整列表中查阅 API 参考。 实例生命周期每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如，实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM 。在这个过程中，实例也会调用一些 生命周期钩子 ，这就给我们提供了执行自定义逻辑的机会。例如，created 这个钩子在实例被创建之后被调用： 12345678910var vm = new Vue(&#123;data: &#123; a: 1&#125;,created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a)&#125;&#125;)// -&gt; \"a is: 1\" 也有一些其它的钩子，在实例生命周期的不同阶段调用，如 mounted、 updated 、destroyed 。钩子的 this 指向调用它的 Vue 实例。一些用户可能会问 Vue.js 是否有“控制器”的概念？答案是，没有。组件的自定义逻辑可以分布在这些钩子中。 生命周期图示下图说明了实例的生命周期。你不需要立马弄明白所有的东西，不过以后它会有帮助。 模板语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染（render）函数，使用可选的 JSX 语法。 插值文本数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值： 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定： 1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 纯HTML双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 v-html 指令： 1&lt;div v-html=\"rawHtml\"&gt;&lt;/div&gt; 被插入的内容都会被当做 HTML —— 数据绑定会被忽略。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。组件更适合担任 UI 重用与复合的基本单元。 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容插值。 属性Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令： 1&lt;div v-bind:id=\"dynamicId\"&gt;&lt;/div&gt; 这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除： 1&lt;button v-bind:disabled=\"someDynamicCondition\"&gt;Button&lt;/button&gt; 使用JavaScript表达式迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值。但实际上，对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持。 1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 1234&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。 指令令（Directives）是带有 v- 前缀的特殊属性。指令属性的值预期是单一 JavaScript 表达式（除了 v-for，之后再讨论）。指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上。让我们回顾一下在介绍里的例子： 1&lt;p v-if=\"seen\"&gt;Now you see me&lt;/p&gt; 这里， v-if 指令将根据表达式 seen 的值的真假来移除/插入 元素。 参数一些指令能接受一个“参数”，在指令后以冒x号指明。例如， v-bind 指令被用来响应地更新 HTML 属性： 1&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt; 在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。另一个例子是 v-on 指令，它用于监听 DOM 事件： 1&lt;a v-on:click=\"doSomething\"&gt; 修饰符修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 之后当我们更深入地了解 v-on 与 v-model时，会看到更多修饰符的使用。 过滤器Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示： 1234&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; Vue 2.x 中，过滤器只能在 mustache 绑定和 v-bind 表达式（从 2.1.0 开始支持）中使用，因为过滤器设计目的就是用于文本转换。为了在其他指令中实现更复杂的数据变换，你应该使用计算属性。 过滤器函数总接受表达式的值作为第一个参数。 12345678910new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 过滤器可以串联： 1&#123;&#123; message | filterA | filterB &#125;&#125; 过滤器是 JavaScript 函数，因此可以接受参数： 1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 这里，字符串 ‘arg1’ 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数。 缩写v- 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识。当你使用 Vue.js 为现有的标记添加动态行为时，它会很有用，但对于一些经常使用的指令来说有点繁琐。同时，当搭建 Vue.js 管理所有模板的 SPA 时，v- 前缀也变得没那么重要了。因此，Vue.js 为两个最为常用的指令提供了特别的缩写： v-bind缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt; v-on缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 它们看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于属性名来说都是合法字符，在所有支持 Vue.js 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。","tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"简单方法","date":"2017-06-28T09:25:26.000Z","path":"2017/06/28/数组方法/","text":"数组方法数组排序从小到大123var arr = [1,2,3,4,5,11,4,5,6,7,8];arr.sort((a,b)=&gt; a-b);//[1, 2, 3, 4, 4, 5, 5, 6, 7, 8, 11] 从大到小123var arr = [1,2,3,4,5,11,4,5,6,7,8];arr.sort((a,b)=&gt; b-a);//[11, 8, 7, 6, 5, 5, 4, 4, 3, 2, 1] 时间函数时间格式Date参数123456789//实例 Wed Jun 28 2017 17:33:36 GMT+0800 (CST)//星期一 MON //星期二 TUE //星期三 WED //星期四 THU //星期五 FRI //星期六 SAT //星期天 SUN//一月 Jan//二月 Feb//三月 Mar//四月 Apr//五月 May//六月 June//七月 July//八月 Aug//九月 Sept//十月 Oct//十一月 Nov//十二月 Dec//第一个参数代表星期几，是英语星期几的简写//第二个参数代表几月份，是英语几月份的简写//也就是说上面的案例代表着：星期三，六月，28日，2017年，17点，33分，36秒，//GMT+0800代表着格林尼治所在地的标准时间。这个+0800指的是北京时间距离标准时间差8个小时//CST CST可视为美国，澳大利亚，古巴或中国的标准时间。 new Date 不接收任何参数：返回当前时间； 123var time = new Date()console.log(time)//Wed Jun 28 2017 17:33:36 GMT+0800 (CST) new Date(x) 接收一个参数x: 返回1970年1月1日 + x毫秒的值。 123var time = new Date(1);console.log(time);//Thu Jan 01 1970 08:00:00 GMT+0800 (CST) new Date().getFullYear() 获取当前年份； 123var time = new Date().getFullYear();console.log(time);//2017 new Date().getMonth() 获取当前月份,从0开始 123var time = new Date().getMonth();console.log(time);//5 new Date().getDate() 获取当前日期 123var time = new Date().getDate();console.log(time)//28 new Date().getDay() 返回当前是星期几 123var time = new Date().getDay();console.log(time)//3 new Date().getTime() 获取从1970.1.1开始的毫秒数（时间戳） 123var time = new Date().getTime();console.log(time);//1498645675319 new Date().getHours() 获取当前小时数（24小时制） 123var time = new Date().getHours();console.log(time);//18 new Date().getMinutes() 获取当前分钟数 123var time = new Date().getMinutes();console.log(time);//29 new Date().getSeconds() 获取当前秒数 123var time = new Date().getSeconds();console.log(time);//16 new Date().getMilliseconds() 获取当前毫秒数 123var time = new Date().getMilliseconds();console.log(time);//168 new Date().toLocaleDateString() 获取当前日期年月日—–格式0000-0-00 123var time = new Date().toLocaleDateString();console.log(time);//2017-6-28 new Date().toLocaleTimeString() 获取当前时间—00：00：00 123var time = new Date().toLocaleTimeString();console.log(time);//\"10:02:12\" new Date().toLocaleString() 获取当前日期年月日时分秒—–格式0000-0-00 00：00：00 123var time = new Date().toLocaleString();console.log(time);//2017-6-28 18:32:51 获取时间戳1234567var time = new Date();//第一种方法time.valueOf();//1498646194237//第二种方法time.getTime();//1498646194237 字符串转日期对象123456789var str = '2017-06-28';new Date(Date.parse(str.replace(/-/g, \"/\")));//Mon Jun 26 2017 00:00:00 GMT+0800 (CST)new Date(2009,1,1);//Sun Feb 01 2009 00:00:00 GMT+0800 (CST)//星期天，二月，一日，2009new Date(\"2009/1/1\");//Thu Jan 01 2009 00:00:00 GMT+0800 (CST)//星期四，一月 时间demo当前系统区域设置格式(toLocaleDateString和toLocaleTimeString)123//例如(new Date()).toLocaleDateString() + \" \" + (new Date()).toLocaleTimeString();//\"2017-6-29 10:05:56\" 普通字符串(toDateString和toTimeString)123//例如 (new Date()).toDateString() + \" \" + (new Date()).toTimeString();//\"Thu Jun 29 2017 10:06:49 GMT+0800 (CST)\" 格林威治标准时间(toGMTString)12(new Date()).toGMTString();//\"Thu, 29 Jun 2017 02:07:41 GMT\" 全球标准时间(toUTCString)12(new Date()).toUTCString();//\"Thu, 29 Jun 2017 02:08:57 GMT\" Date对象字符串(toString)12(new Date()).toString();//\"Thu Jun 29 2017 10:09:40 GMT+0800 (CST)\" 好用的方法时间戳转换时间格式 时间格式2017-6-29 10:16 123456789var time = new Date().valueOf();//1498702568422function getLocalTime(nS) &#123;console.log(parseInt(nS) * 1000,'parseInt(nS) * 1000');console.log((parseInt(nS) * 1000).toLocaleString(),'parseInt(nS) * 1000.toLocaleString()')return new Date(parseInt(nS) * 1000).toLocaleString().replace(/:\\d&#123;1,2&#125;$/,' '); &#125;getLocalTime(time/1000);//\"2017-6-29 10:16 \" 时间方法","tags":[{"name":"Function","slug":"Function","permalink":"http://yoursite.com/tags/Function/"}]},{"title":"有意思的网站","date":"2017-06-27T08:44:02.000Z","path":"2017/06/27/2017年06月27日/","text":"加载动画地址：https://preloaders.net/en/circular描述：许多加载动画，GIF图，SVG，收藏指数：※※※※","tags":[{"name":"一些有用的网站","slug":"一些有用的网站","permalink":"http://yoursite.com/tags/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"}]},{"title":"ITem2APP","date":"2017-06-07T08:38:35.000Z","path":"2017/06/07/ITem2APP/","text":"做一个好看的终端。–Mac 首先呢下载item2，官方的下载地址：https://www.iterm2.com/downloads.html 其次，安装oh-my-zsh sh -c “$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)” 把上边的代码放到item2中执行 前戏准备好了，下面开始正餐 首先要去安装字体。（如果不安装字体，会导致主题出现乱码。） 下载字体的地址：https://github.com/powerline/fonts/ 下载主题的地址：https://github.com/robbyrussell/oh-my-zsh/wiki/Themes 字体对应主题（猜测） 我自己的主题案例 主题下载地址：https://github.com/powerline/fonts/ 字体下载地址：https://github.com/powerline/fonts/blob/master/Inconsolata/Inconsolata%20for%20Powerline.otf主题名字：agnoster 字体安装完成之后，打开ITem2APP Mac 快捷键 command+，打开偏好设置。然后打开Profiles==&gt;Text 修改Font和Non-ASCll Font 字体为；lnconsolata 然后就大功告成。","tags":[{"name":"MacAPP","slug":"MacAPP","permalink":"http://yoursite.com/tags/MacAPP/"}]},{"title":"前端","date":"2017-05-24T06:34:36.000Z","path":"2017/05/24/前端/","text":"这算是有感而发的。今天我老大告诉我们要离职。感觉很不舍。老大教了我们好多东西。也交了我们好多前端上的事情。人生何处不相逢！老大我们有缘再见！ 老大给我们说了前端之后的发展方向。前端发展到一定的地步可以称之为‘大前端’； 大前端包括： 基础的HTML，CSS，jQuery，Bootstrap，JavaScript基本技术。 新鲜的HTML5，CSS3，ECMAScript 6， 最常用的框架：angular，react，Vue 必备知识：Nodejs 可能用得到的：网络运营 需要了解：UI，Java，PHP，GO语言 基本的计算机知识 前端代码的优化：JavaScript，CSS，HTML SEO的优化 总结了之后突然感觉，人生有了方向。希望我这一生可以学完。那我就很满足了。需要了解的知识：百度统计，我的老大叫hjx","tags":[{"name":"人生规划-人生计划","slug":"人生规划-人生计划","permalink":"http://yoursite.com/tags/%E4%BA%BA%E7%94%9F%E8%A7%84%E5%88%92-%E4%BA%BA%E7%94%9F%E8%AE%A1%E5%88%92/"}]},{"title":"meta 标签使用总结","date":"2017-05-03T10:23:43.000Z","path":"2017/05/03/2017年05月03日18-23-40/","text":"Meta标签给搜索引擎提供了许多关于网页的信息。这些信息都是隐含信息,意味着对于网页自身的访问者是不可见的 format-detection用法: 123&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt;&lt;meta name=\"format-detection\" content=\"email=no\"&gt;&lt;meta name=\"format-detection\" content=\"telephone=no,email=no\"&gt; 介绍: 默认telephone=yes, 如果在页面中有一串数字, Safari 会自动给数字添加链接样式,并且点击可跳转到拨号界面.设为 no 则禁止了把数字转为拨号连接.HandheldFriendly用法: 12&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt; 介绍: 功能机时代的事实标签,最早在 AvantGo 用来标识移动内容,后来变成一个通用的标准来标识移动站点.MobileOptimized用法: 1&lt;meta name=\"MobileOptimized\" content=\"320\"&gt; 介绍: 功能机时代的事实标签,用于标识移动内容的另一种方法,改标签的缺点是—特定的宽度必须给出viewport用法: 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,minimal-ui\"&gt; content的几个属性介绍: width: viewport 的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是iOS支持；height: viewport 的高度(范围从223到10000)user-scalable: [yes | no] 是否允许缩放initial-scale : [数值] 初始化比例（范围从 &gt; 0 到 10）minimum-scale : [数值] 允许缩放的最小比例maximum-scale: [数值] 允许缩放的最大比例minimal-ui : IOS7.1的新属性，最小化浏览器UI keywords用法: 1&lt;meta name=\"keywords\" content=\"\"&gt; HTML介绍:这个标签在过去很重要，但是现在却没什么价值了。现在没有一个主流的搜索引擎使用meta keywords来判断网页的内容了。robots用法: 1&lt;meta name=\"robots\" content=\"noindex,nofollow\"&gt; 介绍: Meta robots标签管理着搜索引擎是否可以进入网页，你可以用它来允许或不允许搜索引擎来获取你的网页、进入你网页中的子链接或对你的网页存档。如果你不小心使用了两个矛盾的术语 (例如noindex和index)，谷歌会选择最具限制性的选项。为什么这个标签会对搜索引擎优化(SEO)起作用呢?首先，它可以防止对拷贝内容的冗余抓取，例如页面的打印版页面。它也可能会对那些内容不完整的页面或者而存在私密信息的网页起作用。description用法: 1&lt;meta name=\"description\" content=\"string\"&gt; 介绍: 这个标签曾经在搜索排名中占有很大的比重,但随着算法的不断更新升级,他的地位也逐渐下降.他虽然不会提高网站的排名,但是,因为他会被用在搜索引擎的结果页,所以依然有用.这也就意味着它仍然可以提高你的网页点击率。毕竟，当用户搜索的关键词与之相匹配时，会以粗体显示突出显示。这就是为什么一个好的页面说明 (利用关键字的) 可以显示更多与用户相关的信息，进而提高了点击率。推荐的description长度为160 个字符。author用法: 1&lt;meta name=\"author\" content=\"name,xxx@163.com\"&gt; 介绍: 设置作者和联系方式charset用法: 12&lt;!-- 声明文档使用的字符编码 --&gt;&lt;meta charset='utf-8'&gt; http-equiv 1234&lt;!-- 优先使用 IE 最新版本和 Chrome --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt; renderer 12&lt;!-- 启用360浏览器的极速模式(webkit) --&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; 浏览器强制竖屏 123456789101112&lt;!-- uc强制竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt;","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"2017年04月27日19:01:12","date":"2017-04-27T11:01:14.000Z","path":"2017/04/27/2017年04月27日19-01-12/","text":"以后的东西： 第一：HTML布局 第二：CSS样式 第三：正则表达式 第四：JavaScript高级API 第五：React 第六：Vue","tags":[{"name":"【前端日志】","slug":"【前端日志】","permalink":"http://yoursite.com/tags/%E3%80%90%E5%89%8D%E7%AB%AF%E6%97%A5%E5%BF%97%E3%80%91/"}]},{"title":"名师指点","date":"2017-04-27T10:55:07.000Z","path":"2017/04/27/2017年04月27日/","text":"Mr.hu:前端如果想进步，就必须学着不要使用搜索引擎 不要总是想着在依赖百度编程！谨记这句话可能理解错了，应该是说要明白新的技术是英文的。不要总是在百度搜索。多用谷歌 这算是有感而发的。今天我老大告诉我们要离职。感觉很不舍。老大教了我们好多东西。也交了我们好多前端上的事情。人生何处不相逢！老大我们有缘再见！ 老大给我们说了前端之后的发展方向。前端发展到一定的地步可以称之为‘大前端’； 大前端包括： 基础的HTML，CSS，jQuery，Bootstrap，JavaScript基本技术。 新鲜的HTML5，CSS3，ECMAScript 6， 最常用的框架：angular，react，Vue， 必备知识：Nodejs， 可能用得到的：网络运营， 需要了解：UI，Java，PHP，GO语言， 基本的计算机知识， 前端代码的优化：JavaScript，CSS，HTML， SEO的优化， 需要用到的知识：抛物线、三角函数等等。 抛物线可以用来做动画等等用处。 总结了之后突然感觉，人生有了方向。希望我这一生可以学完。那我就很满足了。需要了解的知识：百度统计，我的老大叫hjx，","tags":[{"name":"前端日记","slug":"前端日记","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%97%A5%E8%AE%B0/"}]},{"title":"2017年04月26日-转","date":"2017-04-26T06:46:56.000Z","path":"2017/04/26/2017年04月26日/","text":"Github: https://github.com/asd0102433/blog css有些属性容易忘记，半天不写就要去查api，有时候api还不好使，于是还是记下来以后方便用，后续会慢慢补充进来的。 Github: https://github.com/asd0102433/blog博客长期更新，喜欢的朋友star一下 outline 移除当选中input元素的时候会出现状态线 An outline is a line that is drawn around elements (outside the borders) to make the element “stand out”. 包裹elements 的一个线，一般设置成none 。 1234div &#123; outline: none; //一般情况下移除它 // outline: 5px dotted red; 也可以设置样式&#125; contenteditable 设置element是否可编辑1&lt;p contenteditable=\"true\"&gt;可编辑&lt;/p&gt; 可以通过input, blur事件来监听element的输入和输入完后鼠标离开。 webkit-playsinline手机video 都可以在页面中播放，而不是全屏播放了。 1&lt;video src=\"test.mp4\" webkit-playsinline=\"true\"&gt;&lt;/video&gt; position: absolute， 让margin有效的 设置left:0, right:0 margin: 0 auto; 就可以。原因是2边都是0不存在边距，element就可以得出距离，并居中。 123456div &#123; position: absolute; left: 0; right: 0; margin: 0 auto;&#125; 使用clearfix 清除浮动，解决父类高度崩塌。123456789101112.clearfix &#123; zoom: 1;&#125;.clearfix:after &#123; visibility: hidden; display: block; font-size: 0; content: \" \"; clear: both; height: 0; &#125; user-select 禁止用户选中文本123div &#123; user-select: none; /* Standard syntax */&#125; 清除手机tap事件后element 时候出现的一个高亮123* &#123; -webkit-tap-highlight-color: rgba(0,0,0,0);&#125; ::-webkit-scrollbar-thumb 可以修改浏览器的滚动条样式。IE火狐可能不支持。 -webkit-appearance:none12To apply platform specific styling to an element that doesn&apos;t have it by defaultTo remove platform specific styling to an element that does have it by default 移除浏览器默认的样式，比如chrome的input默认样式，然后就可以定义需要的样式。 1234input, button, textarea, select &#123; *font-size: 100%; -webkit-appearance:none;&#125; CSS开启硬件加速http://www.cnblogs.com/rubylouvre/p/3471490.html 1-webkit-transform: translateZ(0); 使用CSS transforms 或者 animations时可能会有页面闪烁的bug1-webkit-backface-visibility: hidden; -webkit-touch-callout 禁止长按链接与图片弹出菜单1-webkit-touch-callout: none; transform-style: preserve-3d 让元素支持3d1234div &#123; transform: rotateY(60deg); transform-style: preserve-3d;&#125; perspective 透视这个属性的存在决定你看到的元素是2d还是3d。一般设置在包裹元素的父类上。 123.div-box &#123; perspective: 400px; &#125; css实现不换行、自动换行、强制换行123456789//不换行white-space:nowrap;//自动换行word-wrap: break-word; word-break: normal; //强制换行word-break:break-all; box-sizing 让元素的宽度、高度包含border和padding123&#123; box-sizing: border-box;&#125; calc() function, 计算属性值https://www.w3schools.com/cssref/func_calc.asp 12345678910111213141516 div &#123; width: calc(100% - 100px); &#125;~~~ 上面的例子就是让宽度为100%减去100px的值，项目中很适用，IE9以上# css3 linear-gradient 线性渐变默认开始在top, 也可以自定义方向。~~~css div &#123; linear-gradient(red, yellow) &#125; background: linear-gradient(direction, color-stop1, color-stop2, ...); 常用的选择器 :nth-child() Selector选择父类下第一个子节点，p元素 123p:nth-child(1) &#123; ...&#125; -webkit-font-smoothing 字体抗锯齿使用该属性能让页面上的字体变得清晰，但是也会造成font-weight: bold 加粗变得异常。不信你试试… 12345678910111213141516 div &#123; -webkit-font-smoothing: antialiased; &#125;~~~ ---`更新3-31`# CSS3 filter Property 图片过滤~~~css img &#123; filter: grayscale(100%); //灰度 filter: blur(5px); //模糊 filter:brightness(200%); //高亮 filter:saturate(8); //饱和 filter:sepia(100%); //怀旧 ... &#125; 移动端可以使用，IE兼容不好。更多请看https://www.w3schools.com/cssref/css3_pr_filter.asp 使用css创建三角形这个很多面试题好像问到，但实际中我也确实使用了。 123456789101112131415161718192021222324 div &#123; border-bottom: 10px solid white; border-right: 10px solid transparent; border-left: 10px solid transparent; height: 0px; width: 0px; &#125; transparent 透明~~~ # clip属性，截取你想要显示的图片~~~css img &#123; position: absolute; clip: rect(0px,60px,200px,0px); &#125;~~~ 你有兴趣可以看https://tympanus.net/codrops/2013/01/16/understanding-the-css-clip-property/# 设置文字，字母间距，很实用 letter-spacing~~~css h1 &#123; letter-spacing: *px; //也可以是负数 &#125; 更新4-3 补充 关于display: box 和 display: flex，前者是2009实施，后者2012年，如果你的安卓比较老请使用display: box，但是2者的表现可能有点不同。下面是兼容方法。 123456display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ */display: -moz-box; /* Firefox 17- */display: -webkit-flex; /* Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 */display: -moz-flex; /* Firefox 18+ */display: -ms-flexbox; /* IE 10 */display: flex; /* Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */ 知乎一丝具体问题可以参考这篇文章。 更新4-12 补充 图片模糊效果-webkit-filter: blur(5px); 图片运动过程中，导致图片模糊在animation过程中，图片会出现模糊的情况，可以设置如下在图片上面。 transform: translate3d(0, 0, 0); 后续追加…有错误的地方请指正，谢谢。 下面是一些CSS的网站，项目中也经常使用的。 Css3动画手册Css参考手册Anicollection 动画库Animate 动画库csshake 抖动很逗字体图标w3schools","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Javascript中的Form表单知识点总结","date":"2017-04-24T10:52:49.000Z","path":"2017/04/24/Javascript中的Form表单知识点总结/","text":"转载(http://www.cnblogs.com/tugenhua0707/p/4508986.html) 在HTML中，表单是由form元素来表示的，但是在javascript中，表单则由HTMLFormElement类型，此元素继承了HTMLElement，因此与其他HTML元素具有相同的默认属性；HTMLFormElement有自己以下属性和方法； acceptCharset: 服务器能够处理的字符集；等价于HTML中的accept-charset特性； action: 接收请求的URL，等价于HTML中的action elements: 表单中所有控件的集合. enctype: 请求的编码类型；等价于HTML中的enctype特性； length: 表单中控件的数量； method： 要发送的http请求类型，一般是get或者是post，等价于HTML中的method； name: 表单的名称； reset(): 将所有表单域重置为默认值； submit(): 提交表单； target:用于发送请求和接收响应的窗口名称； 如何获取form表单的引用？ 假如现在页面上有一个form表单元素，html代码如下： 我现在想取到上面的form表单的引用，一共有以下方式可以获取到上面 的form表单引用； 通过获取form表单的id，来获取form表单的引用；如下代码： var formId = document.getElementById(“form”);console.log(formId);2. 通过document.forms 取得页面中的所有表单元素，然后通过索引来取到对应的form元素，如下代码所示：取得页面第一个form元素； console.log(document.forms[0]);3. 通过from表单中的name属性来获取，代码如下： console.log(document.forms[‘form1’]);如何提交表单 下面的所有事件都是来自上一篇博客javascript事件总结的事件，都依赖于此封装的事件，代码如下： 复制代码var EventUtil = { addHandler: function(element,type,handler) { if(element.addEventListener) { element.addEventListener(type,handler,false); }else if(element.attachEvent) { element.attachEvent(“on”+type,handler); }else { element[“on” +type] = handler; } }, removeHandler: function(element,type,handler){ if(element.removeEventListener) { element.removeEventListener(type,handler,false); }else if(element.detachEvent) { element.detachEvent(“on”+type,handler); }else { element[“on” +type] = null; } }, getEvent: function(event) { return event ? event : window.event; }, getTarget: function(event) { return event.target || event.srcElement; }, preventDefault: function(event){ if(event.preventDefault) { event.preventDefault(); }else { event.returnValue = false; } }, stopPropagation: function(event) { if(event.stopPropagation) { event.stopPropagation(); }else { event.cancelBubble = true; } }, getRelatedTarget: function(event){ if (event.relatedTarget){ return event.relatedTarget; } else if (event.toElement){ return event.toElement; } else if (event.fromElement){ return event.fromElement; } else { return null; } }, getWheelDelta: function(event) { if(event.wheelDelta) { return event.wheelDelta; }else { return -event.detail * 40 } }, getCharCode: function(event) { if(typeof event.charCode == ‘number’) { return event.charCode; }else { return event.keyCode; } }};复制代码用户单击提交按钮或图像按钮时，就会提交表单，使用input或者button都可以提交表单，只需将type设置为submit或者image即可，如下三种方式都可以； 第一种： 第二种： submit 第三种： 我们也可以通过如下方式提交表单，但是也可以阻止form表单提交：如下代码： 复制代码EventUtil.addHandler(formId,”submit”,function(event){ // 取得事件对象 event = EventUtil.getEvent(event); // 阻止默认事件 EventUtil.preventDefault(event);});复制代码如何重置表单 如果我们使用按钮重置表单的话，有下面2种方式： 第一种代码如下： 第二种代码如下： reset 我们也可以通过像提交form表单一样来进行重置表单，代码如下： var formId = document.getElementById(“form”);formId.reset();如何访问表单字段？ 第一种方式我们可以使用dom节点来访问； 第二种方式：每个表单都有elements属性，该属性是表单中所有表单元素的集合；这个elements是个有序列表；包含着所有字段，比如有input,textarea,button,fieldset等； 比如如下HTML代码： 复制代码 111 复制代码 JS获取表单字段如下： 复制代码var formId = document.getElementById(“form”);// 取得表单中的第一个字段var firstCol = formId.elements[0];console.log(firstCol);// 取得名字name为select1的字段console.log(formId.elements[‘select1’]);// 取得表单中包含字段的数量console.log(formId.elements.length);复制代码如果一个表单中，有多个name相同的属性，那么取得数据是一个集合，如下HTML代码： JS代码如下： var formId = document.getElementById(“form”);var radios = formId.elements[“radio2”];console.log(radios.length); // 打印3共有的表单字段属性 所有的表单字段都有一组相同的属性；表单共有的属性如下： disabled: 布尔值，表示当前字段是否被禁用； form: 指向当前字段所属表单的指针，只读； name: 当前字段的名称; readOnly:布尔值，表示当前字段是否可读。 tabIndex: 表示当前字段的切换(tab)序号。 type: 当前字段的类型，如checkbox,radio等； value: 当前字段被提交到服务器的值； 共有的表单字段方法 每个表单字段都有两个方法focus()和blur()，其中focus是获取焦点；比如在页面加载完成后，我希望form表单中的第一个字段获取焦点（除隐藏域之外）；如下代码： JS代码如下： var formId = document.getElementById(“form”);EventUtil.addHandler(window,’load’,function(event){ formId.elements[0].focus();});但是HTML5中为表单字段新增了一个autofocus属性，在支持这个属性浏览器中，如果设置了这个属性，不用javascript就能将焦点移动到某个输入框下，比如如下HTML代码，在页面加载完成后，我把焦点放在第二个输入框内，如下HTML代码： 支持autofocus属性的浏览器有：firefox4+，safari5+，chrome和Opera9.6+ 但是我想要兼容其他不支持autofocus的浏览器，我们可以写一段JS，为了全兼容； 复制代码var formId = document.getElementById(“form”);EventUtil.addHandler(window,’load’,function(event){ var element = formId.elements[1]; if(element.autofocus !== true) { element.focus(); }});复制代码因为autofocus是一个布尔值，支持他的浏览器默认为true；不支持他的浏览器，默认值为空字符串； 共有的表单字段事件 所有的表单字段都支持以下三个事件； blur:当前字段失去焦点时触发； change:对于input和textarea元素，值发生改变的时候触发； focus: 当前字段获得焦点时触发； 理解文本框脚本 在HTML中，有2种方式来实现文本框，一种是input元素的单行文本框，另一种是textarea元素的多行文本框； input元素有属性type=”text”, 还可以通过设置size属性，用来指定文本框显示的字符数，还可以设置value，用来显示文本框的初始值，还可以设置maxlength属性，用于指定文本框可以接受的最大字符数；如下代码： 多行文本框textarea也有一些属性，这里就不做多介绍了； 如何选择文本： input和select两种元素都支持select()方法，这个方法用于选择文本框中的所有文本，在调用select()方法中(除Opera外),都会将焦点设置到文本框中，这个方法不接受任何参数，如下代码： JS代码如下： var formId = document.getElementById(“formId”);formId.elements[‘input’].select();如下图所示： 如上是页面一进来的时候，默认选择input元素框所有的内容；我们也可以当获取焦点的时候，就选中所有的内容，JS代码可以改为如下： 复制代码var formId = document.getElementById(“formId”),input = formId.elements[‘input’];EventUtil.addHandler(input,”focus”,function(event){ event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); target.select();});复制代码在火狐和谷歌浏览器下能实现当获取焦点的时候，就选中input元素框内的所有内容，但是在IE7或者8下，还是页面加载完后就已经选中了文本框内的所有元素； 选择事件(select) 与select方法对应的，还有一个select事件，在IE9+，firefox，chrome，opera和safari中，只有用户选择了文本且释放鼠标时，会触发select事件；但是在IE8及以下，只要用户选择了一个字母且不必释放鼠标，就会触发select事件；如下代码： var formId = document.getElementById(“formId”),input = formId.elements[‘input’];EventUtil.addHandler(input,”select”,function(event){ alert(input.value);});2. 取的选择的文本 虽然通过select事件我们知道用户什么时候选择了文本，但是我们并不知道用户选择了什么文本，在HTML5中，我们通过两个属性selectionStart和selectionEnd，这两个属性表示选择的范围(即文本区开头和结尾的偏移量)；因此要取得用户选择的文本，可以使用如下代码； 复制代码var formId = document.getElementById(“formId”), input = formId.elements[‘input’];EventUtil.addHandler(input,”select”,function(event){ alert(getSelectedText(input));});function getSelectedText(elem) { return elem.value.substring(elem.selectionStart,elem.selectionEnd);}复制代码但是目前浏览器支持程度有：IE9+，firefox，chrome，Opera及safari； IE8及之前的版本不支持这两个属性，但是他们提供了另外一种document.selection对象，其中保存着用户在整个文档范围内选择的文本信息，但是呢与前面的select事件使用在一起的话，只能选择一个字符就会触发事件，也就是说，不能选择大于1和字符的文字，不过可以知道选择的值时多少；如下代码： 复制代码var formId = document.getElementById(“formId”),input = formId.elements[‘input’];EventUtil.addHandler(input,”select”,function(event){ alert(getSelectedText(input));});function getSelectedText(elem) { if(typeof elem.selectionStart == “number”) { return elem.value.substring(elem.selectionStart,elem.selectionEnd); }else if(document.selection) { return document.selection.createRange().text; }}复制代码选择部分文本 HTML5也为选择文本框中的部分文本提供了解决方案，使用setSelectionRange()方法，这个方法接收2个参数，要选择的第一个字符的索引，和要选择的最后一个字符之后的字符的索引； 浏览器支持有：IE9+，chrome，safari和opera，firefox貌似不支持； 代码如下： var formId = document.getElementById(“formId”), input = formId.elements[‘input’];input.value = “我是龙恩，我是中国人”;// 选择所有文本input.setSelectionRange(0,input.value.length);截图如下： // 选择前3个字符 input.setSelectionRange(0,3);截图如下： // 选择第四到第六个字符 input.setSelectionRange(4,7); 截图如下： IE8及以下版本可以使用范围来选择部分文本，要选择部分文本，必须首先使用IE在所有文本框中提供的createTextRange()方法创建一个范围，且我们需要使用collapse()将范围折叠到文本框的开始位置，再使用moveStart()和moveEnd()这两个范围方法将范围移动到位； 如下代码选择所有的文本： 复制代码input.value = “我是龙恩，我是中国人”;var range = input.createTextRange();// 选择所有文本range.collapse(true);range.moveStart(“character”,0);range.moveEnd(“character”,input.value.length);range.select();复制代码演示如下： 切记：使用F5刷新没有用的，要在地址栏中，然后按enter键刷新即可看到效果； // 选择前3个字符range.collapse(true);range.moveStart(“character”,0);range.moveEnd(“character”,3);range.select();演示如下： // 选择第4到第6个字符range.collapse(true);range.moveStart(“character”,4);range.moveEnd(“character”,3);range.select();演示如下： 为了让跨浏览器效果，我们可以封装一个方法，如下： 复制代码function selectText(elem,startIndex,stopIndex) { if(elem.setSelectionRange) { elem.setSelectionRange(startIndex,stopIndex); }else if(elem.createTextRange) { var range = elem.createTextRange(); range.collapse(true); range.moveStart(“character”,startIndex); range.moveEnd(“character”,stopIndex - startIndex); range.select(); }}复制代码测试数据如下：貌似firefox不支持 复制代码// 选择所有文本selectText(input,0,input.value.length); // 选择前3个字符selectText(input,0,3); // 选择第四个字符到第六个字符selectText(input,4,7);复制代码过滤输入 有时候我们会要求用户在输入框里面输入特定格式的数据，我们就可以使用过滤输入这种手段来进行了，首先我们来看看如何屏蔽字符； 屏蔽字符 比如我在一个input输入框中，只允许只能输入数字，那么我们可以先获取通过keypress事件来监听，然后每次获取到键码，然后通过String.fromCharCode()这个方法，把键码转换成字符串，然后通过正则判断下，如果不是数字，直接阻止默认事件即可不让用户输入，如下代码： JS代码如下： 复制代码var formId = document.getElementById(“formId”),input = formId.elements[‘input’];EventUtil.addHandler(input,’keypress’,function(event) { event = EventUtil.getEvent(event); var charCode = EventUtil.getCharCode(event); if(!/\\d/.test(String.fromCharCode(charCode))) { EventUtil.preventDefault(event); }});复制代码如上代码能满足日常需求，但是有些游览器，比如firefox，safari(3.1版本之前)会对向上键，向下键，退格键和删除键也会触发keypress事件了；所以为了避免这些事件的发生，我们需要做一些处理来满足所有版本的浏览器的需求，我们发现在firefox中，所有由非字符键触发keypress键码都为0；而在safari3以前的版本中，对应的字符编码全部为8；所以我们要对字符编码进行判断下； 如下代码： 复制代码EventUtil.addHandler(input,’keypress’,function(event) { event = EventUtil.getEvent(event); var charCode = EventUtil.getCharCode(event); if(!/\\d/.test(String.fromCharCode(charCode)) &amp;&amp; charCode &gt; 9) { EventUtil.preventDefault(event); }});复制代码操作剪贴板 到目前为止，IE，chrome，safari，opera都支持剪贴板事件，貌似firefox就不支持了（书上说支持）；但是我操作就不支持了；下面是6个操作剪贴板事件；如下： beforecopy: 在发生复制操作前触发； copy: 在发生复制操作时触发； beforecut: 在发生剪贴操作前触发； cut: 在发生剪贴操作时触发； beforepaste: 在发生黏贴操作前触发； paste: 在发生粘帖操作时触发； 针对上面的事件，我们可以使用如下代码测试下就可以证明了；代码如下所示： EventUtil.addHandler(input,’beforecopy’,function(event) { alert(1);});如果要访问剪贴板中的数据，可以使用clipboardData对象，在IE中，这个对象是window对象的属性，在safari或者chrome上，这个对象是event的属性，这个clipboardData对象有三个方法，getData(),setData(),和clearData(); getData()是从剪贴板中取得数据，他接受一个参数，即要取得数据的格式，在IE中，有二种数据格式”text” 和 “url”，在safari和chrome中这个参数是一种MIME类型，不过，可以使用text代表text/plain. setData()方法是给剪贴板设置文本，接受2个参数，第一个数据是数据类型；第二个参数是放在剪贴板中的文本；但是此方法接受的数据类型只能是text/plain,不能是text；因此为了全兼容浏览器(出firefox外)，我们可以写一个通用的方法出来，如下： 复制代码getClipboardText: function(event) { var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData(“text”); },setClipboardText:function(event,value) { if(event.clipboardData) { return event.clipboardData.setData(“text/plain”,value); }else if(window.clipboardData) { return window.clipboardData.setData(“text”,value); }}复制代码因此EventUtil封装的所有方法如下： 复制代码var EventUtil = { addHandler: function(element,type,handler) { if(element.addEventListener) { element.addEventListener(type,handler,false); }else if(element.attachEvent) { element.attachEvent(“on”+type,handler); }else { element[“on” +type] = handler; } }, removeHandler: function(element,type,handler){ if(element.removeEventListener) { element.removeEventListener(type,handler,false); }else if(element.detachEvent) { element.detachEvent(“on”+type,handler); }else { element[“on” +type] = null; } }, getEvent: function(event) { return event ? event : window.event; }, getTarget: function(event) { return event.target || event.srcElement; }, preventDefault: function(event){ if(event.preventDefault) { event.preventDefault(); }else { event.returnValue = false; } }, stopPropagation: function(event) { if(event.stopPropagation) { event.stopPropagation(); }else { event.cancelBubble = true; } }, getRelatedTarget: function(event){ if (event.relatedTarget){ return event.relatedTarget; } else if (event.toElement){ return event.toElement; } else if (event.fromElement){ return event.fromElement; } else { return null; } }, getWheelDelta: function(event) { if(event.wheelDelta) { return event.wheelDelta; }else { return -event.detail * 40 } }, getCharCode: function(event) { if(typeof event.charCode == ‘number’) { return event.charCode; }else { return event.keyCode; } }, getClipboardText: function(event) { var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData(“text”); }, setClipboardText:function(event,value) { if(event.clipboardData) { return event.clipboardData.setData(“text/plain”,value); }else if(window.clipboardData) { return window.clipboardData.setData(“text”,value); } }};复制代码测试代码如下：还是上面测试输入框的值是否为数字；每次粘帖上次，都能获取到黏贴的是文字数据，代码如下： HTML代码如下： JS代码如下： 复制代码var formId = document.getElementById(“formId”),input = formId.elements[‘input’];EventUtil.addHandler(input,’paste’,function(event) { event = EventUtil.getEvent(event); var text = EventUtil.getClipboardText(event); alert(text); if (!/^\\d*$/.test(text)){ EventUtil.preventDefault(event); }});复制代码理解自动切换输入框或者textarea的焦点 比如我们在填写表单的页面上，当用户输入完自己的数据的时候，不需要用户手动切换到下一个输入框里面去，我们可以自动切换去，这样的话，对于用户体验来说，比较方便，比如我们现在页面上有一个form表单，这里为了做测试，我们先用一个输入框用于手机号码的，另外一个是textarea，当手机号码输入11位数字后，会自动切换到textarea中；当然页面中的隐藏域除外；代码如下： HTML代码如下： JS代码如下： 复制代码var formId = document.getElementById(“formId”),input = formId.elements[‘input’];EventUtil.addHandler(input,’keyup’,tabForward);function tabForward(event) { event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); if(target.value.length == target.maxLength) { // 获取当前的form表单的引用 var form = target.form; for(var i = 0, ilen = form.elements.length; i &lt; ilen; i++) { if(form.elements[i] == target) { if(form.elements[i+1]) { form.elements[i+1].focus(); } return; } } }}复制代码理解HTML5新增属性 required属性； 比如在HTML5中对表单input，textarea，或者select标签的话，提交表单时，需要判断是否为空，特别对于在做移动端的朋友来说，可以使用HTML5中的新增属性required；如下HTML代码： 提交时候，在chrome下看到效果如下： 在firefox下，提示如下： 如上是根据不同的浏览器本身的性质来提示的，因此样式不同，所以适合在移动端根据本身浏览器内核来提示； 但是在Javascript是如何判断的呢？比如如下HTML代码： JS代码如下： 复制代码var formId = document.getElementById(“formId”),submit = formId.elements[‘submit’];EventUtil.addHandler(submit,’click’,function(event) { var isRequired = formId.elements[“submit”].required; console.log(isRequired);});复制代码如上打印出false；可以获取到submit的属性required，如果输入框值为空的话，会打印出false出来； 如果想知道浏览器是否支持required这个属性的话，我们可以使用如下代码判断下，如果返回true，说明支持，否则不支持；如下： var isRequiredSupported = “required” in document.createElement(“input”);console.log(isRequiredSupported);input输入框类型type的值是email或者url email类型要求输入的文本必须符合电子邮件的格式，url类型要求输入的文本必须符合URL的格式；如下chrome浏览器截图如下； 选择框脚本 选择框是通过和元素创建的，除了表单所有的共有属性和方法外，HTMLSelectElement类还提供了下列属性和方法； add(newOption,relOption);向控件中插入新元素，其位置在relOption之前； multiple:布尔值; 表示是否允许多项选择，等价于HTML中的multiple特性； options: 控件中所有元素的HTMLCollection； remove(index): 移除给定位置的选项； selectedIndex: 基于0的选中索引，如果没有该选项，则值为 -1； size: 选择框中的可见的行数。 如下select框代码： 复制代码 A B C D E 复制代码 JS代码如下： 复制代码var formId = document.getElementById(“formId”),select = formId.elements[‘location’];console.log(select.value);EventUtil.addHandler(select,’change’,function(){ console.log(select.value)});复制代码第一次页面加载完成后，打印出值为A； 当每次切换的时候，如果有value就打印出值，如果value=””;则打印空字符串，但是如果option选项没有指定value，在firfox和chrome下打印出当前的文本值，比如上面的文本为E，则值为E；但是IE8及以下，打印的还是空字符串； 在DOM中，每个元素都有一个HTMLOptionElement对象表示；为方便访问数据，对象添加了如下属性； index: 当前选项在options集合中的索引； label： 当前选项的标签，等价于HTML中的label selected：布尔值，表示当前选项是否被选中，将这个属性设置为true可以选中当前选项。 text：选项的文本； value：选项的值； 我们还是以上面的form表单作为HTML代码，我们使用JS来测试下： 如下代码： 复制代码var formId = document.getElementById(“formId”),select = formId.elements[‘location’];// 获取options集合中的第一项选项的文本console.log(select.options[0].text); // 打印出A// 获取options集合中的第一项选项的valueconsole.log(select.options[0].value); // 打印出A复制代码对于下拉框只能选择一项的选择框，访问最简单的方式，就是使用selectedIndex属性，如下HTML代码： 复制代码 A B C D E 复制代码 假如页面初始化的时候默认选择第二项，那么我们可以先使用selectedIndex的属性获取选中的索引，然后根据索引获取当前的文本和值；如下JS代码： 复制代码var formId = document.getElementById(“formId”),select = formId.elements[‘location’];// 获取当前选中的选项的索引selectedIndexvar selectedIndex = select.selectedIndex;// 获取索引为selectedIndex的optionvar selectedOption = select.options[selectedIndex];console.log(“selected index:”+selectedIndex+”\\nselect text:”+selectedOption.text+”\\nselect value:”+selectedOption.value);复制代码添加选项 可以使用javascript动态创建选项，并将它们添加到选择框中，添加选择框有以下常见3种方式； 第一种方式使用DOM的方式如下： HTML代码如下： &lt;/select&gt; JS代码如下： 复制代码var formId = document.getElementById(“formId”),select = formId.elements[‘location’];var newOption = document.createElement(“option”);newOption.appendChild(document.createTextNode(“A”));newOption.setAttribute(“value”,”AAAA”);select.appendChild(newOption);复制代码第二种方式使用Option构造函数来创建新选项，Option构造函数接收2个参数，文本(text)和值(value),第二个参数可选，比如如下代码： var formId = document.getElementById(“formId”),select = formId.elements[‘location’];var newOption = new Option(“Option text”,”Option value”);select.appendChild(newOption);但是这种方式在IE下是不生效的； 下面我们来看看第三种方式吧！是使用选择框add()方法，DOM规定这个方法接收2个参数，要添加的新选项和将位于新选项之后的选项，如果想在列表的最后添加一个选项，应将第二个参数设置为null；在IE对add()方法的实现中，第二个参数是可选的，但是标准DOM浏览器中，必须要指定第二个参数，因此为了全兼容浏览器，我们必须添加第二个参数，但是我们可以将第二个参数设置为undefined，含义是：在所有的浏览器将新选项插入到列表的最后了~ 如下代码： var formId = document.getElementById(“formId”),select = formId.elements[‘location’];var newOption = new Option(“Option text”,”Option value”);select.add(newOption,undefined);移除选项的方式如下： 使用dom的removeChild()方法，为其传入要移除的选项；如下代码：HTML代码如下： 复制代码 A B C 复制代码 Javascript代码如下： var formId = document.getElementById(“formId”),select = formId.elements[‘location’];// 第一种：移除第一项如下方式select.removeChild(select.options[0]);2. 第二种方式是使用选择框的remove()方法，这个方法接收一个参数，既要移除选项的索引；如下代码： var formId = document.getElementById(“formId”),select = formId.elements[‘location’];// 移除第一项select.remove(0);3. 最后一种方式，就是将相应的选项设置为null，如下代码： var formId = document.getElementById(“formId”),select = formId.elements[‘location’];// 移除第一项select.options[0] = null;理解表单序列化 在javascript中，可以利用表单字段的type属性，连同name和value属性一起实现对表单的序列化，序列化后将把这些数据发送给服务器。 下面是将那些字段需要进行序列化的； 对表单字段的名称和值进行URL编码，使用&amp;分割；不发送禁用的表单字段；只发送勾选的单选框和复选框按钮数据；不发送type为reset和button的按钮多选选择框中的每个选中的值单独一个条目；Select元素的值，就是选中option元素的value的值，如果option没有属性value，则是选中的文本值；如下JS代码是封装form表单的序列化的JS如下： // 序列化JS代码封装 复制代码function serialize(form) { var arrs = [], field = null, i, len, j, optLen, option, optValue; for(i = 0,len = form.elements.length; i &lt; len; i++) { field = form.elements[i]; switch(field.type) { case “select-one”: case “select-multiple”: if(field.name.length) { for(j = 0,optLen = field.options.length; j &lt; optLen; j++) { option = field.options[j]; if(option.selected) { optValue = ‘’; if(option.hasAttribute) { optValue = option.hasAttribute(“value”) ? option.value : option.text; }else { optValue = option.attributes[“value”].specified ? option.value : option.text; } arrs.push(encodeURIComponent(field.name) + “=” +encodeURIComponent(optValue)); } } } break; case undefined: //字段集 case “file”: // 文件输入 case “submit”: // 提交按钮 case “reset”: // 重置按钮 case “button”: // 自定义按钮 break; case &quot;radio&quot;: // 单选框 case &quot;checkbox&quot;: // 复选框 if(!field.checked) { break; } /* 执行默认动作 */ default: // 不包含没有名字的表单字段 if(field.name.length) { arrs.push(encodeURIComponent(field.name) + &quot;=&quot; +encodeURIComponent(field.value)); } } } return arrs.join(&quot;&amp;&quot;);}复制代码 如上对form表单序列化的函数serialize，定义了一个arrs数组，用来保存需要序列化后的名值对，然后通过for循环迭代每个表单中的字段，先使用临时变量field保存表单中任意一个字段的引用，然后使用switch语句判断字段的类型type(如果type未定义的话，此元素就不需要表单序列化)，第一种情况是select的单选和多选框，对于select单选框，只可能有一个选中项，对于多选框可能有零或多个选中项，如果有选中项的话(通过属性selected来判断)，需要确定使用什么值，如果不存在value特性，或者虽然存在该特性，但是值为空字符串，都是使用选项的文本来代替，为检查这个特性，在兼容DOM的浏览器下我们需要使用hasAttribute()方法，而在IE中需要使用特性的specified属性；对于type=“file”或者submit，reset，button等就不支持，如果比如上传图片的时候，需要图片的二进制数据使用form表单提交的话，可以在序列化后在加上这个参数即可；对于单选框和复选框如果没有选中的话，同样不进行序列化；下面我们现在来看看一个demo吧！如下HTML代码： 复制代码 A B C 1 2 3 4 5 复制代码 JS代码如下： 复制代码var formId = document.getElementById(“formId”);console.log(serialize(formId));var submit = formId.elements[‘submit’];EventUtil.addHandler(submit,’click’,function(e){ EventUtil.preventDefault(e); console.log(serialize(formId));});复制代码我们看到上面的form表单代码，上面有select单选框，也有select多选框，也有隐藏域和input框，但是请注意：上面name=”a”和name=”b”，当他们选中的时候，没有值属性，所以在各个浏览器上都会自带一个值为on的值传给服务器端，但是这个并不是我们想要的，所以的如果需要值的话，一定要设置值，如下如下截图： 在火狐和谷歌下截图如下： 在IE下： 上面的select多选框，如果需要多选的话，记得先要按住键盘上的ctrl键就可以多选了，比如上面的select2=2&amp;select2=3&amp;select2=4 就是select框多选。 理解富文本编辑 在网页中编辑内容，IE最早引入这个功能，随后opera，safari，firefox和chrome也实现了这个功能，基本原理就是在页面中嵌入一个空HTML页面的iframe，通过设置designMode属性，这个空白的HTML页面可以添加文字，而添加文字则是该页面的body元素的html代码，如下所示： designMode有2个属性，off（默认值）和on, 当设置为on的时候，整个文档变得可编辑，但是我们也可以给他们添加css样式，为了更加美观；首先我们先来看看demo，如下HTML页面嵌套一个iframe； 而bank.html页面是一个空页面，代码如下： 复制代码 Document 复制代码 然后在主页面上使用JS，当页面加载完成后，将designMode属性设置为on即可，如下JS代码： EventUtil.addHandler(window,’load’,function(event){ frames[‘richedit’].document.designMode = “on”;});然后在页面上显示如下： 第二种实现方式是使用contenteditable属性来实现 contenteditable属性是有IE最早实现的，可以把contenteditable属性给页面中的任何元素，然后用户可以立即编辑该元素，不需要iframe，空页面及JS，只需要使用contenteditable属性即可；如下代码给div设置contenteditable属性；如下代码： 在浏览器下效果如下： 支持的浏览器有；IE，firefox，chrome，safari和opera； 在移动设备上，有ios5+和Android3+； Contenteditable属性有三个可能值，true表示打开，false表示关闭，inherit表示从父元素那边继承。","tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Mac版 sublime text 3 快捷键","date":"2017-04-20T13:52:22.000Z","path":"2017/04/20/Mac版-sublime-text-3-快捷键/","text":"一、快速生成HTML5的头部信息的步骤： 1.Ctrl + N，新建一个文档； 2.Ctrl + Shift + P，打开命令模式，再输入 sshtml 进行模糊匹配，将语法切换到html模式；切换语法 3.输入 !，再按下 Tab键或者 Ctrl + E ，就能快速打开HTML5的整体结构。 二、常用的快捷键： Ctrl + P，打开搜索框。具体操作为：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。command + F 搜索当前文件函数、方法Ctrl + 回车，在当前行的下一行添加一行空行。Ctrl + Shift + 回车，在当前行的上一行添加一行空行。Ctrl + Z，撤销。Ctrl + Y，取消撤销。Ctrl + ]，或者Tab键，向右缩进。Ctrl + [，或者Shift +Tab，向左缩进。Ctrl + Shift + V，粘贴过程中保持缩进。Alt + F3，选中选择的词。“&gt;”号，子元素选择符；“.”号，后面跟的是class名；“$”符，代表的是序号。 举个例子：输入 ul&gt;.item$*10,再按下Ctrl + E，则会一次性输出一个无需列表，列表中有10个带有class名为item的 li 行。 无疑这种一次性输入多行的方式十分快捷。如果多行有同一种操作，可以运用多行游标，Alt + F3会选中鼠标之前选择的词，此时多行被选中，按方向键可以选择 选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M 光标移动至括号内结束或开始的位置。Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。Ctrl+Shift+] 选中代码，按下快捷键，展开代码。Ctrl+K+0 展开所有折叠代码。Ctrl+← 向左单位性地移动光标，快速移动光标。Ctrl+→ 向右单位性地移动光标，快速移动光标。shift+↑ 向上选中多行。shift+↓ 向下选中多行。Shift+← 向左选中文本。Shift+→ 向右选中文本。Ctrl+Shift+← 向左单位性地选中文本。Ctrl+Shift+→ 向右单位性地选中文本。Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D 复制光标所在整行，插入到下一行。Tab 向右缩进。Shift+Tab 向左缩进。Shift+Tab 向左缩进。Ctrl+K+K 从光标处开始删除代码至行尾。Ctrl+Shift+K 删除整行。Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。Ctrl+K+U 转换大写。Ctrl+K+L 转换小写。Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2 设置书签Ctrl+T 左右字母互换。F6 单词检测拼写搜索类 Ctrl+F 打开底部搜索框，查找关键字。Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。Esc 退出光标多行选择，退出搜索框，命令框等。显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。Ctrl+PageDown 向左切换当前窗口的标签页。Ctrl+PageUp 向右切换当前窗口的标签页。Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏Ctrl+K+B 开启/关闭侧边栏。F11 全屏模式Shift+F11 免打扰模式","tags":[{"name":"Mac APP","slug":"Mac-APP","permalink":"http://yoursite.com/tags/Mac-APP/"}]},{"title":"React表格项目使用","date":"2017-04-15T19:24:47.000Z","path":"2017/04/16/React表格项目使用/","text":"总结只有两个字“很坑”。个人理解，用表格。要看’行’里看列，而不是从’列’里看行。demo： ``` &lt;thead&gt; &lt;tr&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td colSpan={6}&gt;这是头部1&lt;/td&gt; &lt;td colSpan={7}&gt;这是头部1&lt;/td&gt; &lt;td colSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td colSpan={3}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;td rowSpan={2}&gt;这是头部1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;12&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2017-5&lt;/td&gt; &lt;td&gt;759849&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;1004340000&lt;/td&gt; &lt;td&gt;546&lt;/td&gt; &lt;td&gt;656&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;546他&lt;/td&gt; &lt;td&gt;1000&lt;/td&gt; &lt;td&gt;400&lt;/td&gt; &lt;td&gt;600&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;321&lt;/td&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;201&lt;/td&gt; &lt;td&gt;321&lt;/td&gt; &lt;td&gt;321&lt;/td&gt; &lt;td&gt;321&lt;/td&gt; &lt;td&gt;-100&lt;/td&gt; &lt;td&gt;-100&lt;/td&gt; &lt;td&gt;-100&lt;/td&gt; &lt;td&gt;/&lt;/td&gt; &lt;td&gt;10000&lt;/td&gt; &lt;td&gt;sdfgerefd&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; ``","tags":[{"name":"table","slug":"table","permalink":"http://yoursite.com/tags/table/"}]},{"title":"css div居中","date":"2017-04-14T08:31:56.000Z","path":"2017/04/14/css-div居中/","text":"使用css3将一个div水平和垂直居中显示使用css3将一个div水平和垂直居中显示 方案一： div绝对定位水平垂直居中【margin:auto实现绝对定位元素的居中】， 代码两个关键点：1.上下左右均0位置定位； 2.margin: auto; 其width、height如何更改都是居中显示的，兼容性可以,IE7及之前版本不支持 复制代码 .div1{ width: 100px; height: 100px; border: 4px solid red; position: absolute; left:0; right:0; top: 0; bottom: 0; margin: auto; /50%为自身尺寸的一半/ }代码 优点： 1.支持跨浏览器，包括IE8-IE10. 2.无需其他特殊标记，CSS代码量少 3.支持百分比%属性值和min-/max-属性 4.只用这一个类可实现任何内容块居中 5.不论是否设置padding都可居中（在不使用box-sizing属性的前提下） 6.内容块可以被重绘。 7.完美支持图片居中。 缺点： 1.必须声明高度（查看可变高度Variable Height）。 2.建议设置overflow:auto来防止内容越界溢出。（查看溢出Overflow）。 3.在Windows Phone设备上不起作用。 浏览器兼容性： Chrome,Firefox, Safari, Mobile Safari, IE8-10. 绝对定位方法在最新版的Chrome,Firefox, Safari, Mobile Safari, IE8-10.上均测试通过。 方案二： div绝对定位水平垂直居中【margin 负间距】 此方案代码关键点：1.必需知道该div的宽度和高度，2.然后设置位置为绝对位置，3.距离页面窗口左边框和上边框的距离设置为50%，这个50%就是指页面窗口的宽度和高度的50%，4.最后将该div分别左移和上移，左移和上移的大小就是该DIV宽度和高度的一半。 复制代码.div1{ width: 100px; height: 100px; border: 4px solid red; position: absolute; text-align: center; left:50%; top: 50%; margin: -50px 0 0 -50px; /*50%为自身尺寸的一半*/}亦可写成： .div1{ width: 100px; height: 100px; background-color: green; position: absolute; text-align: center; left:50%; top: 50%; margin-left: -50px; /* width/2 */ margin-top: -50px; /* height /2 */ } 这或许是当前最流行的使用方法。 测试表明，这是唯一在IE6-IE7上也表现良好的方法。 优点： 良好的跨浏览器特性，兼容IE6-IE7。 代码量少。 缺点： 不能自适应。不支持百分比尺寸和min-/max-属性设置。 内容可能溢出容器。 边距大小与padding,和是否定义box-sizing: border-box有关，计算需要根据不同情况。 方案三： div绝对定位水平垂直居中【Transforms 变形】 这是最简单的方法，不仅能实现绝对居中同样的效果，也支持联合可变高度方式使用。内容块定义transform: translate(-50%,-50%) 必须加上top: 50%; left: 50%; .div1{ width: 200px; height: 200px; background-color: pink; position: absolute; text-align: center; left:50%; top: 50%; /*-webkit-transform: translate(-50%,-50%);*/ /*-ms-transform: translate(-50%,-50%);*/ transform: translate(-50%,-50%);} 优点： 内容可变高度 代码量少缺点： IE8不支持 属性需要写浏览器厂商前缀 可能干扰其他transform效果 某些情形下会出现文本或元素边界渲染模糊的现象 若只是水平（方向）居中： 复制代码.div1{ width: 100px; height: 100px; border: 4px solid red; text-align: center; margin: 0 auto; /50%为自身尺寸的一半/} css3不定宽高水平垂直居中 只要三句话就可以实现不定宽高水平垂直居中。 1 justify-content:center;//子元素水平居中2 align-items:center;//子元素垂直居中3 display:-webkit-flex;在父级元素上面加上上面3句话，就可以实现子元素水平垂直居中。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"es6新特性概览","date":"2017-04-13T14:49:58.000Z","path":"2017/04/13/es6新特性概览/","text":"ES6新特性概览（转）原文地址：http://www.cnblogs.com/Wayou/p/es6_new_features.html本文基于lukehoban/es6features ，同时参考了大量博客资料，具体见文末引用。 ES6（ECMAScript 6）是即将到来的新版本JavaScript语言的标准，代号harmony(和谐之意，显然没有跟上我国的步伐，我们已经进入中国梦版本了)。上一次标准的制订还是2009年出台的ES5。目前ES6的标准化工作正在进行中，预计会在14年12月份放出正式敲定的版本。但大部分标准已经就绪，且各浏览器对ES6的支持也正在实现中。要查看ES6的支持情况请点此。 目前想要运行ES6代码的话，可以用google/traceur-compiler将代码转译。点此访问traceur-compiler 在线版本时实编辑ES6代码并查看转换后的结果，代码运行结果会在console显示。 另外，关于Google Traceur，业界大神Addy Osmani利用前者写了个Chrome插件ES6 Tepl，安装后也可以进行ES6的测试。 当然，并不是所有ES6新特性都被实现了，所以上面的方法可以测试大部分，有一些还是无法测试的。 虽然ES6都还没真正发布，但已经有用ES6重写的程序了，各种关于ES789的提议已经开始了，这你敢信。潮流不是我等大众所能追赶的。 潮流虽然太快，但我们不停下学习的步伐，就不会被潮流丢下的，下面来领略下ES6中新特性，一堵新生代JS的风采。 箭头操作符 如果你会C#或者Java，你肯定知道lambda表达式，ES6中新增的箭头操作符=&gt;便有异曲同工之妙。它简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。 我们知道在JS中回调是经常的事，而一般回调又以匿名函数的形式出现，每次都需要写一个function，甚是繁琐。当引入箭头操作符后可以方便地写回调了。请看下面的例子。 var array = [1, 2, 3];//传统写法array.forEach(function(v, i, a) { console.log(v);});//ES6array.forEach(v = &gt; console.log(v));大家可以打开文章开头提到的traceur在线代码转译页面输入代码来查看效果。 类的支持 ES6中添加了对类的支持，引入了class关键字（其实class在JavaScript中一直是保留字，目的就是考虑到可能在以后的新版本中会用到，现在终于派上用场了）。JS本身就是面向对象的，ES6中提供的类实际上只是JS原型模式的包装。现在提供原生的class支持后，对象的创建，继承更加直观了，并且父类方法的调用，实例化，静态方法和构造函数等概念都更加形象化。 下面代码展示了类在ES6中的使用。再次啰嗦一句，你可以将代码贴到traceur自己查看运行结果。 //类的定义class Animal { //ES6中新型构造器 constructor(name) { this.name = name; } //实例方法 sayName() { console.log(‘My name is ‘+this.name); }}//类的继承class Programmer extends Animal { constructor(name) { //直接调用父类构造器进行初始化 super(name); } program() { console.log(“I’m coding…”); }}//测试我们的类var animal=new Animal(‘dummy’),wayou=new Programmer(‘wayou’);animal.sayName();//输出 ‘My name is dummy’wayou.sayName();//输出 ‘My name is wayou’wayou.program();//输出 ‘I’m coding…’ 增强的对象字面量 对象字面量被增强了，写法更加简洁与灵活，同时在定义对象的时候能够做的事情更多了。具体表现在： 可以在对象字面量里面定义原型定义方法可以不用function关键字直接调用父类方法这样一来，对象字面量与前面提到的类概念更加吻合，在编写面向对象的JavaScript时更加轻松方便了。 //通过对象字面量创建对象var human = { breathe() { console.log(‘breathing…’); }};var worker = { proto: human, //设置此对象的原型为human,相当于继承human company: ‘freelancer’, work() { console.log(‘working…’); }};human.breathe();//输出 ‘breathing…’//调用继承来的breathe方法worker.breathe();//输出 ‘breathing…’ 字符串模板 字符串模板相对简单易懂些。ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。如果你使用过像C#等后端强类型语言的话，对此功能应该不会陌生。 //产生一个随机数var num=Math.random();//将这个数字输出到consoleconsole.log(your num is ${num});解构 自动解析数组或对象中的值。比如若一个函数要返回多个值，常规的做法是返回一个对象，将每个值做为这个对象的属性返回。但在ES6中，利用解构这一特性，可以直接返回一个数组，然后数组中的值会自动被解析到对应接收该值的变量中。 var [x,y]=getVal(),//函数返回值的解构 [name,,age]=[‘wayou’,’male’,’secrect’];//数组解构 function getVal() { return [ 1, 2 ];} console.log(‘x:’+x+’, y:’+y);//输出：x:1, y:2console.log(‘name:’+name+’, age:’+age);//输出： name:wayou, age:secrect参数默认值，不定参数，拓展参数 默认参数值 现在可以在定义函数的时候指定参数的默认值了，而不用像以前那样通过逻辑或操作符来达到目的了。 function sayHello(name){ //传统的指定默认参数的方式 var name=name||’dude’; console.log(‘Hello ‘+name);}//运用ES6的默认参数function sayHello2(name=’dude’){ console.log(Hello ${name});}sayHello();//输出：Hello dudesayHello(‘Wayou’);//输出：Hello WayousayHello2();//输出：Hello dudesayHello2(‘Wayou’);//输出：Hello Wayou 不定参数 不定参数是在函数中使用命名参数同时接收不定数量的未命名参数。这只是一种语法糖，在以前的JavaScript代码中我们可以通过arguments变量来达到这一目的。不定参数的格式是三个句点后跟代表所有不定参数的变量名。比如下面这个例子中，…x代表了所有传入add函数的参数。 //将所有参数相加的函数function add(…x){ return x.reduce((m,n)=&gt;m+n);}//传递任意个数的参数console.log(add(1,2,3));//输出：6console.log(add(1,2,3,4,5));//输出：15 拓展参数 拓展参数则是另一种形式的语法糖，它允许传递数组或者类数组直接做为函数的参数而不用通过apply。 var people=[‘Wayou’,’John’,’Sherlock’];//sayHello函数本来接收三个单独的参数人妖，人二和人三function sayHello(people1,people2,people3){ console.log(Hello ${people1},${people2},${people3});}//但是我们将一个数组以拓展参数的形式传递，它能很好地映射到每个单独的参数sayHello(…people);//输出：Hello Wayou,John,Sherlock //而在以前，如果需要传递数组当参数，我们需要使用函数的apply方法sayHello.apply(null,people);//输出：Hello Wayou,John,Sherlocklet与const 关键字 可以把let看成var，只是它定义的变量被限定在了特定范围内才能使用，而离开这个范围则无效。const则很直观，用来定义常量，即无法被更改值的变量。 for (let i=0;i&lt;2;i++)console.log(i);//输出: 0,1console.log(i);//输出：undefined,严格模式下会报错for of 值遍历 我们都知道for in 循环用于遍历数组，类数组或对象，ES6中新引入的for of循环功能相似，不同的是每次循环它提供的不是序号而是值。 var someArray = [ “a”, “b”, “c” ]; for (v of someArray) { console.log(v);//输出 a,b,c}注意，此功能google traceur并未实现，所以无法模拟调试,下面有些功能也是如此 iterator, generator 这一部分的内容有点生涩，详情可以参见这里。以下是些基本概念。 iterator:它是这么一个对象，拥有一个next方法，这个方法返回一个对象{done,value}，这个对象包含两个属性，一个布尔类型的done和包含任意值的valueiterable: 这是这么一个对象，拥有一个obj[@@iterator]方法，这个方法返回一个iteratorgenerator: 它是一种特殊的iterator。反的next方法可以接收一个参数并且返回值取决与它的构造函数（generator function）。generator同时拥有一个throw方法generator 函数: 即generator的构造函数。此函数内可以使用yield关键字。在yield出现的地方可以通过generator的next或throw方法向外界传递值。generator 函数是通过function*来声明的yield 关键字：它可以暂停函数的执行，随后可以再进进入函数继续执行模块 在ES6标准中，JavaScript原生支持module了。这种将JS代码分割成不同功能的小块进行模块化的概念是在一些三方规范中流行起来的，比如CommonJS和AMD模式。 将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用。下面的例子来自tutsplus: // point.jsmodule “point” { export class Point { constructor (x, y) { public x = x; public y = y; } }} // myapp.js//声明引用的模块module point from “/point.js”;//这里可以看出，尽管声明了引用的模块，还是可以通过指定需要的部分进行导入import Point from “point”; var origin = new Point(0, 0);console.log(origin);Map，Set 和 WeakMap，WeakSet 这些是新加的集合类型，提供了更加方便的获取属性值的方法，不用像以前一样用hasOwnProperty来检查某个属性是属于原型链上的呢还是当前对象的。同时，在进行属性值添加与获取时有专门的get，set 方法。 下方代码来自es6feature // Setsvar s = new Set();s.add(“hello”).add(“goodbye”).add(“hello”);s.size === 2;s.has(“hello”) === true; // Mapsvar m = new Map();m.set(“hello”, 42);m.set(s, 34);m.get(s) == 34;有时候我们会把对象作为一个对象的键用来存放属性值，普通集合类型比如简单对象会阻止垃圾回收器对这些作为属性键存在的对象的回收，有造成内存泄漏的危险。而WeakMap,WeakSet则更加安全些，这些作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉，具体还看下面的例子。 正文代码来自es6feature // Weak Mapsvar wm = new WeakMap();wm.set(s, { extra: 42 });wm.size === undefined // Weak Setsvar ws = new WeakSet();ws.add({ data: 42 });//因为添加到ws的这个临时对象没有其他变量引用它，所以ws不会保存它的值，也就是说这次添加其实没有意思 Proxies Proxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。一下子让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。 以下例子借用自这里。 //定义被侦听的目标对象var engineer = { name: ‘Joe Sixpack’, salary: 50 };//定义处理程序var interceptor = { set: function (receiver, property, value) { console.log(property, ‘is changed to’, value); receiver[property] = value; }};//创建代理以进行侦听engineer = Proxy(engineer, interceptor);//做一些改动来触发代理engineer.salary = 60;//控制台输出：salary is changed to 60上面代码我已加了注释，这里进一步解释。对于处理程序，是在被侦听的对象身上发生了相应事件之后，处理程序里面的方法就会被调用，上面例子中我们设置了set的处理函数，表明，如果我们侦听的对象的属性被更改，也就是被set了，那这个处理程序就会被调用，同时通过参数能够得知是哪个属性被更改，更改为了什么值。 Symbols 我们知道对象其实是键值对的集合，而键通常来说是字符串。而现在除了字符串外，我们还可以用symbol这种值来做为对象的键。Symbol是一种基本类型，像数字，字符串还有布尔一样，它不是一个对象。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。之后就可以用这个返回值做为对象的键了。Symbol还可以用来创建私有属性，外部无法直接访问由symbol做为键的属性值。 以下例子来自es6features (function() { // 创建symbol var key = Symbol(“key”); function MyClass(privateData) { this[key] = privateData; } MyClass.prototype = { doStuff: function() { … this[key] … } }; })(); var c = new MyClass(“hello”)c[“key”] === undefined//无法访问该属性，因为是私有的 Math，Number，String，Object 的新API 对Math,Number,String还有Object等添加了许多新的API。下面代码同样来自es6features，对这些新API进行了简单展示。 Number.EPSILONNumber.isInteger(Infinity) // falseNumber.isNaN(“NaN”) // false Math.acosh(3) // 1.762747174039086Math.hypot(3, 4) // 5Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2 “abcde”.contains(“cd”) // true“abc”.repeat(3) // “abcabcabc” Array.from(document.querySelectorAll(‘*’)) // Returns a real ArrayArray.of(1, 2, 3) // Similar to new Array(…), but without special one-arg behavior[0, 0, 0].fill(7, 1) // [0,7,7][1,2,3].findIndex(x =&gt; x == 2) // 1[“a”, “b”, “c”].entries() // iterator [0, “a”], [1,”b”], [2,”c”][“a”, “b”, “c”].keys() // iterator 0, 1, 2[“a”, “b”, “c”].values() // iterator “a”, “b”, “c” Object.assign(Point, { origin: new Point(0,0) }) Promises Promises是处理异步操作的一种模式，之前在很多三方库中有实现，比如jQuery的deferred 对象。当你发起一个异步请求，并绑定了.when(), .done()等事件处理程序时，其实就是在应用promise模式。 //创建promisevar promise = new Promise(function(resolve, reject) { // 进行一些异步或耗时操作 if ( /*如果成功 */ ) { resolve(“Stuff worked!”); } else { reject(Error(“It broke”)); }});//绑定处理程序promise.then(function(result) { //promise成功的话会执行这里 console.log(result); // “Stuff worked!”}, function(err) { //promise失败会执行这里 console.log(err); // Error: “It broke”});总结 总结就是一句话，前后端差异越来越小了。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"2017年04月13日21:52:30","date":"2017-04-13T13:52:34.000Z","path":"2017/04/13/2017年04月13日21-52-30/","text":"hexo主题圆满完成！！💪加油学习哦","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"2017年04月13日11:25:54","date":"2017-04-13T03:25:57.000Z","path":"2017/04/13/2017年04月13日11-25-54/","text":"主题已经切换完了，比较简单。git clone https://github.com/smackgg/hexo-theme-smackdown.git 然后修改配置文件_config.yml中的theme: smackdown就好啦。(^o^)/YES!下面就需要进行第三方插件的使用了。例如百度统计等。。。。💪","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]